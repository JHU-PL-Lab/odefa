# Reading `symbolic_generator.ml`

top-level definitions

`rv (cls: clause list) : var`
get the last clause in `cls`, then get the `var` of that clause

`rv_of_function (fcn:value) : var`
get `rv` of the function

`script formulas_list`
invoke python script for Z3

`make_map clauses graph : (var,clause_body) Hashtbl.t`
add `clauses` into the `graph`, which is a hashtable from `var` to function `body`

`get_annotated_clause_from_json (edge:Yojson.Basic.json list) map : annotated_clause`
used in `initialize_graph`

`initialize_graph (map: (var,clause_body) Hashtbl.t) (elements:Yojson.Basic.json list) graph: (annotated_clause,annotated_clause) Hashtbl.t`
parse a json file to a graph

`mayBeTop`
Stack API

`find_context var (node:annotated_clause) context_stack graph phi: clause Stack.t`
Stack helper API

`lookup`
core function
used in `eval_helper` and itself recursively
but not in `eval`

`eval_helper`
used in `lookup` and `eval`

`eval (Expr(cls)) : Core_ast.var * value Core_interpreter.Environment.t * formula * input_mapping`
enter point

## `eval` details in `symbolic_generator.ml`
1. `cls` is the input expression from toplevel
2. `map` is the hash table for `graph`, which is from `var` to `clause` 
3. `json` is the file outputed by ddpa toploop
4. `json_of_graph` is the graph of 2, which is a list
5. `elements` in the json is the edges of ddpa
6. In `initialize_graph`, it contains `Hashtbl.add graph node2 node1` and the `node2` and `node1` are from the elements. Therefore, we will get the `graph` from the `map` (expression from the toplevel) and `elements` (ddpa graph)
7. Q: `elements` are `graph` should be from the same program
8. (`print_graph`)
9. `lookup_stack` created
10. `context_stack` created
11. `phi` is a list of `formula`
12. `clause_list` seems another list of the program
13. `starting_program_point` is the searching start point
14. `let _ = find_clause_by_var graph starting_program_point` seems a sanity check to ensure the graph is generated by the same program from ddpa
15. put `stack` into a `queue`
16. call the `eval_helper` with the `queue`
17. get the result `output_val` and `phi` from it
18. add the result to `core_interpreter.Environment`, which is a hash table(`core_ast.Var_hasktbl`).

## wrapping and `eval_helper` details in `symbolic_generator.ml`

1. `eval_helper queue prompt_user : Core_ast.value * formula list`
2. check `queue` is not empty (return if empty)
3. match `Done`, print and return
4. match `Double_working`, add two states in the queue and loop `eval_helper`
5. match `Working`, `lookup` to get `new_state`
6. if (5) get `Working` or `Double_working`, loop `eval_helper`
7. if (5) get `Done`, **call Z3** **What is Double_working?**

## `lookup` details in `symbolic_generator.ml`

1. `lookup (lookup_stack:(var * (clause Stack.t)) Stack.t) (node:annotated_clause) context_stack graph phi: program_state `
2. `cur_var` is at the top of `lookup_stack`
3. `a1` is the annotation clause for `node`
4. case `a1` on `Unannotated_clause` `Enter_clause` `Exit_clause` `Conditional_enter_clause` `Conditional_exit_clause` `Start_clause` `End_clause` `Junk_clause`
5. These cases are omit `Conditional_enter_clause` `Conditional_exit_clause` `Start_clause` `End_clause` `Junk_clause`
6. In `Unannotated_clause` case, if `x <> cur_var`, then Skip
7. comments for other cases are add to the code directly
8. In `Binary` case, more sub-cases are discussed

# Reading `core_interpreter_utils.ml`

These helper functions are used in `symbolic_generator.ml`.

type definition is used.

`find_starting_node_2`
`find_clause_by_var`
`find_by_value`
`get_non_exit_clause_node`
`matching_node`
`get_exit_nodes`
`trim_list`

Some `string_of_*` and `print_*` are used in `symbolic_generator.ml`.

# Interaction with other files

`symbolic_generator.ml` is required in the library task `core-interpreter`, together with `core_interpreter_utils.ml`.

library `core-interpreter` is required in the library task `core-toploop`, which is for executable `core_toploop`.

library `core-interpreter` is also required in the executable task `test`.

Call trace:

`core_toploop_main`.()
-> `core_toploop.handle_expression`
-> `core_toploop.do_evaluation`
-> `symbolic_generator.eval e`

# Todo

`symbolic_generator.ml` line 694, the solver didn't take the output back from the sat solver...


`core_interpreter_utils.ml` line 214, in `string_of_formula_2` when getting string of a var formula, the `freshening_stack` seems ignored.


The definition of `type formala` seems not good since it's not arbitrary nested and it make adding expressions in Z3 harder.

In general, we have formula like:
x = 1
x = y
(x <= 1) Or (1 <= x)  # we need to add once in the top formula
x = not y
x = x `op` y
pat = 1
x = pat


Using parsing in OCaml Z3 may be an alternative (see `Z3.SMT.parse_smtlib2_string `)

`core_toploop.ml` line 52-57
```
    if conf.topconf_wddpac_interpreter then
      (* Core_interpreter_wddpac_naive_2.eval e (* if you pass in -W you use concrete *) *)
      Symbolic_generator.eval e
    else
      (* Core_interpreter_wddpac_naive_2.eval e *)
      Symbolic_generator.eval e
```

This change is made at commit 54da563 at Feb 10 2019 when removing wddpac_2 from compilation config.
Not sure if it's work or not.