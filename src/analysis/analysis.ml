(**
   This module gives an implementation of the DDPA analysis.  It is parametric
   in the choice of context stack.
*)

open Batteries;;

open Analysis_context_stack;;
open Ast;;
open Ast_pp;;
open Ddpa_graph;;
open Nondeterminism;;
open Pds_reachability_types_stack;;
open String_utils;;

let logger = Logger_utils.make_logger "Analysis";;
let lazy_logger = Logger_utils.make_lazy_logger "Analysis";;

exception Non_record_projection of string;;

module type Analysis_sig =
sig
  (** The type of the DDPA analysis generated by the module. *)
  type ddpa_analysis

  (** The context stack module for this analysis. *)
  module C : Context_stack;;

  (** The initial, unclosed analysis derived from an expression. *)
  val create_initial_analysis :
    ?logging_prefix:string option -> expr -> ddpa_analysis

  (** Pretty-prints a DDPA structure. *)
  val pp_ddpa : ddpa_analysis -> string

  (** Get size of DDPA and underlying PDS.  The return values are, in order,
      + The number of DDPA nodes in the analysis (except for those which can
        be inferred)
      + The number of active, non-immediate, non-inferrable DDPA nodes
      + The number of edges in the DDPA graph
      + The number of nodes in the PDS
      + The number of edges in the PDS
      + The number of contexts used in the PDS
  *)
  val get_size : ddpa_analysis -> int * int * int * int * int * int

  (** Performs a series of closure steps on an analysis.  This is not guaranteed
      to complete closure; however, it will make progress as long as the
      argument is not fully closed. *)
  val perform_closure_steps : ddpa_analysis -> ddpa_analysis

  (** Determines if an analysis is fully closed. *)
  val is_fully_closed : ddpa_analysis -> bool

  (** Fully closes an analysis. *)
  val perform_full_closure : ddpa_analysis -> ddpa_analysis

  (** Determines the values at a given position of the provided variable in the
      given analysis.  This is an approximation -- false positives may arise --
      but it is guaranteed to be conservative if the analysis is fully closed.
      The returned analysis contains a cache structure to accelerate answering
      of this question in the future. *)
  val values_of_variable :
    var -> annotated_clause -> ddpa_analysis ->
    Abs_filtered_value_set.t * ddpa_analysis

  val contextual_values_of_variable :
    var -> annotated_clause -> C.t -> ddpa_analysis ->
    Abs_filtered_value_set.t * ddpa_analysis

  (** Sets the logging level for the PDS reachability analysis used by this
      module. *)
  val set_pdr_logger_level :
    Pds_reachability_logger_utils.pds_reachability_logger_level -> unit

  (** Gets the logging level for the PDS reachability analysis used by this
      module. *)
  val get_pdr_logger_level :
    unit -> Pds_reachability_logger_utils.pds_reachability_logger_level

end;;

(**
   A functor which constructs a DDPA analysis module.
*)
module Make(C : Context_stack)
  : Analysis_sig with module C = C =
struct
  module C = C;;

  let rv body =
    match body with
    | [] -> raise @@
      Utils.Invariant_failure "empty function body provided to rv"
    | _ -> let Abs_clause(x,_) = List.last body in x
  ;;

  (* FIXME: the following restriction isn't in the spec, but maybe it should be... just here to test things for now *)
  (* The `pattern_set' passed into this function must not contain the empty record pattern. Use the following guard to test:
      (* FIXME: the following isn't in the spec, but maybe it should be... just here to test things for now *)
      [% guard (not @@
                    Pattern_set.mem (Record_pattern Ident_map.empty) pattern_set) ];
  *)
  let negative_pattern_set_selection record_type pattern_set =
    let (Record_value m) = record_type in
    let record_labels = Ident_set.of_enum @@ Ident_map.keys m in
    let relevant_patterns = pattern_set
                            |> Pattern_set.enum
                            |> Enum.filter
                              (fun pattern ->
                                 match pattern with
                                 | Record_pattern m' ->
                                   Ident_set.subset (Ident_set.of_enum @@ Ident_map.keys m')
                                     record_labels
                                 | _ -> false)
    in
    (* This function selects a single label from a given pattern and constructs
       a pattern from it. *)
    let pick_pattern pattern =
      match pattern with
      | Record_pattern m' ->
        let open Nondeterminism_monad in
        let%bind (k,v) = pick_enum @@ Ident_map.enum m' in
        return @@ Record_pattern(Ident_map.singleton k v)
      | _ -> raise @@ Utils.Invariant_failure ("The non-record pattern `" ^ pp_pattern pattern ^ "' ended up on `analysis.ml:negative_pattern_set_selection:pick_pattern'.")
    in
    let open Nondeterminism_monad in
    let%bind selected_patterns =
      Nondeterminism_monad.mapM pick_pattern relevant_patterns
    in
    return @@ Pattern_set.of_enum selected_patterns
  ;;

  (* `pattern' /must/ satisfy the `is_record_pattern_set' predicate. Note that
     the results of `negative_pattern_set_selection' already satisfy it. *)
  let pattern_projection pattern label =
    match pattern with
    | Record_pattern m ->
      begin
        try
          Some (Ident_map.find label m)
        with
        | Not_found -> None
      end
    | _ -> raise @@ Non_record_projection ("Tried to project out of a non-record pattern `" ^ pp_pattern pattern ^ "' in `analysis.ml:pattern_projection'.")
  ;;

  let pattern_set_projection set label =
    set
    |> Pattern_set.enum
    |> Enum.map (flip pattern_projection label)
    |> Enum.filter_map identity
    |> Pattern_set.of_enum
  ;;

  let is_record_pattern_set set =
    set
    |> Pattern_set.enum
    |> Enum.for_all
      (
        fun pattern ->
          match pattern with
          | Record_pattern _ -> true
          | _ -> false
      )
  ;;

  let labels_in_record (Record_value m) =
    Ident_set.of_enum @@ Ident_map.keys m
  ;;

  (* `pattern' /must/ satisfy the `is_record_pattern_set' predicate. Note that
     the results of `negative_pattern_set_selection' already satisfy it. *)
  let labels_in_pattern pattern =
    match pattern with
    | Record_pattern m ->
      Ident_set.of_enum @@ Ident_map.keys m
    | _ -> raise @@ Non_record_projection ("Tried to enumerate labels out of a non-record pattern `" ^ pp_pattern pattern ^ "' in `analysis.ml:labels_in_pattern'.")
  ;;

  let labels_in_pattern_set set =
    set
    |> Pattern_set.enum
    |> Enum.map labels_in_pattern
    |> Enum.fold Ident_set.union Ident_set.empty
  ;;

  let is_immediate acl =
    match acl with
    | Unannotated_clause(abs_clause) -> is_abstract_clause_immediate abs_clause
    | Enter_clause _
    | Exit_clause _ -> true
    | Start_clause
    | End_clause -> false
  ;;

  (** This module is meant to verify that the system never attempts to create
   *  a capture size larger than a fixed maximum (here, 4).  This property is
   *  necessary to argue that the analysis is decidable.
  *)
  module Bounded_capture_size :
  sig
    type bounded_capture_size;;
    val compare_bounded_capture_size :
      bounded_capture_size -> bounded_capture_size -> int
    (*val equal_bounded_capture_size :
      bounded_capture_size -> bounded_capture_size -> bool*)
    val make_bounded_capture_size : int -> bounded_capture_size
    val int_of_bounded_capture_size : bounded_capture_size -> int
  end =
  struct
    type bounded_capture_size =
      | Bounded_capture_size of int
      [@@deriving ord]
    ;;
    let max_capture_size = 5;;
    let make_bounded_capture_size n =
      if n >= 1 && n <= max_capture_size
      then Bounded_capture_size(n)
      else raise @@ Utils.Invariant_failure(
          Printf.sprintf "Invalid size %d provided for bounded capture" n);;
    let int_of_bounded_capture_size (Bounded_capture_size(n)) = n;;
  end;;
  open Bounded_capture_size;;

  type pds_continuation =
    | Bottom_of_stack
    (** The bottom of stack element is necessary as a sentinel. It's pushed as
        the initial element on the continuation stack so we don't need to check
        for empty continuation stacks. *)
    | Lookup_var of var * Pattern_set.t * Pattern_set.t
    | Project of ident * Pattern_set.t * Pattern_set.t
    | Jump of annotated_clause * C.t
    | Deref of Pattern_set.t * Pattern_set.t
    | Capture of bounded_capture_size
    | Continuation_value of abs_filtered_value
    | Real_flow_huh
    | Alias_huh
    | Side_effect_search_start
    | Side_effect_search_escape of var
    | Side_effect_lookup_var of
        var * Pattern_set.t * Pattern_set.t * annotated_clause * C.t
    | Binary_operation
    | Unary_operation
    | Indexing
    [@@deriving ord]
  ;;

  module Pds_continuation_ord =
  struct
    type t = pds_continuation
    let compare = compare_pds_continuation
  end;;

  let pp_pds_continuation = function
    | Bottom_of_stack ->
      "Bottom_of_stack"
    | Lookup_var(x,patsp,patsn) ->
      Printf.sprintf "%s(%s/%s)"
        (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Project(i,patsp,patsn) ->
      Printf.sprintf ".%s(%s/%s)"
        (pp_ident i) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Jump(acl,ctx) ->
      Printf.sprintf "Jump(%s,%s)" (pp_annotated_clause acl) (C.pp ctx)
    | Deref(patsp,patsn) ->
      Printf.sprintf "!(%s,%s)" (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Capture(size) ->
      Printf.sprintf "Capture(%d)" @@ int_of_bounded_capture_size size
    | Continuation_value(fv) -> pp_abs_filtered_value fv
    | Real_flow_huh -> "RealFlow?"
    | Alias_huh -> "Alias?"
    | Side_effect_search_start -> "Side_effect_search_start"
    | Side_effect_search_escape x ->
      Printf.sprintf "Side_effect_search_escape(%s)" (pp_var x)
    | Side_effect_lookup_var(x,patsp,patsn,acl,ctx) ->
      Printf.sprintf "Side_effect_lookup_var(%s,%s,%s,%s,%s)"
        (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
        (pp_annotated_clause acl) (C.pp ctx)
    | Binary_operation -> "Binary_operation"
    | Unary_operation -> "Unary_operation"
    | Indexing -> "Indexing"
  ;;

  let ppa_pds_continuation = function
    | Bottom_of_stack -> "Bot"
    | Lookup_var(x,patsp,patsn) ->
      if Pattern_set.is_empty patsp && Pattern_set.is_empty patsn
      then pp_var x
      else Printf.sprintf "%s(%s/%s)"
          (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Project(i,patsp,patsn) ->
      if Pattern_set.is_empty patsp && Pattern_set.is_empty patsn
      then Printf.sprintf ".%s" (pp_ident i)
      else Printf.sprintf ".%s(%s/%s)"
          (pp_ident i) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Jump(acl,ctx) ->
      Printf.sprintf "Jump(%s,%s)"
        (ppa_annotated_clause acl) (C.ppa ctx)
    | Deref(patsp,patsn) ->
      Printf.sprintf "!(%s,%s)" (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Capture(size) ->
      Printf.sprintf "Capture(%d)" @@ int_of_bounded_capture_size size
    | Continuation_value(fv) -> pp_abs_filtered_value fv
    | Real_flow_huh -> "RealFlow?"
    | Alias_huh -> "Alias?"
    | Side_effect_search_start -> "SEStart"
    | Side_effect_search_escape x ->
      Printf.sprintf "SEEsc(%s)" (pp_var x)
    | Side_effect_lookup_var(x,patsp,patsn,acl,ctx) ->
      Printf.sprintf "SEVar(%s,%s,%s,%s,%s)"
        (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
        (pp_annotated_clause acl) (C.pp ctx)
    | Binary_operation -> "BinOp"
    | Unary_operation -> "UnOp"
    | Indexing -> "Idx"
  ;;

  type pds_state =
    | Program_point_state of annotated_clause * C.t
    (** A state in the PDS representing a specific program point and
        context. *)
    | Result_state of abs_filtered_value
    (** A state in the PDS representing a value result. *)
    [@@deriving ord]
  ;;

  let pp_pds_state state =
    match state with
    | Program_point_state(acl,ctx) ->
      Printf.sprintf "(%s @ %s)" (pp_annotated_clause acl) (C.pp ctx)
    | Result_state(Abs_filtered_value(v,patsp,patsn)) ->
      Printf.sprintf "(%s(%s/%s))"
        (pp_abstract_value v) (pp_pattern_set patsp) (pp_pattern_set patsn)
  ;;

  let ppa_pds_state state =
    match state with
    | Program_point_state(acl,ctx) ->
      Printf.sprintf "(%s @ %s)" (ppa_annotated_clause acl) (C.ppa ctx)
    | Result_state(Abs_filtered_value(v,patsp,patsn)) ->
      Printf.sprintf "(%s(%s/%s))"
        (pp_abstract_value v) (pp_pattern_set patsp) (pp_pattern_set patsn)
  ;;

  module Program_point_state_ord =
  struct
    type t = pds_state
    let compare = compare_pds_state
  end;;

  module Ddpa_pds_reachability_basis =
  struct
    type state = pds_state
    type stack_element = pds_continuation
    module State_ord = Program_point_state_ord
    module Stack_element_ord = Pds_continuation_ord
    let pp_state = pp_pds_state
    let pp_stack_element = pp_pds_continuation
    let ppa_state = ppa_pds_state
    let ppa_stack_element = ppa_pds_continuation
  end

  type pds_targeted_dynamic_pop_action =
    | Value_drop
    (** An action to drop values from the top of the stack.  This is necessary
        for actions such as non-local lookup which perform a subordinate
        lookup but do not act upon the resulting value. *)
    | Value_discovery_2_of_2
    (** The second step of value discovery, which confirms that the special
        "bottom" stack element is next on the stack.  This step pops that
        element so that the targeted value state can be accepted (by empty
        stack).  Note that the first step of value discovery is untargeted. *)
    | Variable_aliasing of var * var
    (** Represents variable aliasing, as in "x = y".  The first variable
        is the one being declared; the second variable is the one being
        used.  This pop action is used for every rule which performs basic
        x-to-y aliasing regardless of whether the clause in question is
        annotated. *)
    | Stateless_nonmatching_clause_skip_1_of_2 of var
    (** Represents the first step of skipping a non-matching clause while
        stateless.  If we are searching for x, we may skip over any clause of
        the form x'' = b (even if b is non-immediate) as long as we are not
        trying to dereference x''.  The first step of this process captures
        the variable which we should *not* match.  The second step carries
        the variable continuation and confirms the absence of a dereference
        continuation. *)
    | Stateless_nonmatching_clause_skip_2_of_2 of pds_continuation
    (** The second step of skipping a non-matching clause while stateless. *)
    | Value_capture_1_of_3
    (** Represents the first step of the value capture action.  This step
        pops and stores the value being captured. *)
    | Value_capture_2_of_3 of abs_filtered_value
    (** Represents the second step of the value capture action.  This step
        extracts the number of other stack elements to gather up before
        capturing the value. *)
    | Value_capture_3_of_3 of
        abs_filtered_value * pds_continuation list * bounded_capture_size
    (** Represents the third step of the value capture action.  This action
        collects other stack elements into a list until it has consumed as
        many as the original Capture stack element dictated.  It then pushes
        a value to the stack followed by all of the elements it collected. *)
    | Function_call_flow_validation of var * var * annotated_clause * C.t
                                       * annotated_clause * C.t * var
    (** Represents the validation of a function at a call site to ensure that
        we only explore exit nodes which apply in this context.  The first
        variable is the called function. The second variable is the argument
        passed to the function.  The given states are used to build the targets
        to which to jump once the function argument has been validated and
        once a function value has been discovered.  The third variable is the
        call site for which this validation is occurring. *)
    | Function_call_flow_validation_resolution_1_of_2 of var * var
    (** The first step of resolving function call flow validation.  The first
        variable is the call site; the second variable is the return variable
        for the called function's wiring node. *)
    | Function_call_flow_validation_resolution_2_of_2 of var * var
    (** We've captured the "RealFlow?" and now expect to see a value. *)
    | Function_closure_lookup of var * var
    (** Represents a function closure lookup.  The first variable is the
        parameter of the function; the second variable is the function itself.
        If the lookup variable does not match the parameter, then this lookup
        is for a non-local and we must search for the function's definition
        first. *)
    | Conditional_closure_lookup of var * var * pattern * bool
    (** Represents a conditional closure lookup.  The first variable is the
        formal parameter of the case branch that we are leaving from the top.
        The second variable is the subject of the pattern match.  The provided
        pattern is the pattern against which the subject was matched; the
        boolean is true if the match succeeded and false otherwise. *)
    | Conditional_subject_validation of
        var * var * var * pattern * bool * annotated_clause * C.t
    (** Represents the handling of an exit wiring node for a conditional.  The
        first variable is the conditional site; the second variable is the
        return variable of the conditional branch.  The third variable is the
        subject of the conditional; it is followed by the conditional's
        pattern.  The boolean indicates whether this is the "then" branch
        (true) or the "else" branch (false).  The state and context refer to
        this wiring clause so a jump can be issued after the subject is
        validated in this branch. *)
    | Record_projection_lookup of var * var * ident
    (** Represents the start of a record projection.  If the first variable
        matches our lookup target, then we've discovered that we are looking
        up the projection of the ident label from a record stored in the
        second variable. *)
    | Record_projection_1_of_2
    (** Represents the processing of a record projection on the stack.  This
        action requires two steps: one to grab the record and one to grab the
        value. *)
    | Record_projection_2_of_2 of record_value * Pattern_set.t * Pattern_set.t
    (** The second step of handling record projection. *)
    | Function_filter_validation of var * abstract_function_value
    (** Represents the validation of filters for a function under lookup.  If
        the variable matches our lookup variable, only the `fun' filter on the
        positive set is admissible and anything but `fun' in the negative
        filters is admissible and can be erased. *)
    | Record_filter_validation of
        var * record_value * annotated_clause * C.t
    (** Represents the validation of filters for a record under lookup.  If
        the variable matches our lookup variable, we will perform a series
        of lookups on each field of the record to validate that this record
        does, in fact, exist.  Once those lookups succeed, the resulting
        record value will replace the lookup variable on the stack.  The
        PDS state given here is the source node (which follows the record
        assignment node in control flow); it is used to construct the
        subordinate lookups used in filter validation. *)
    | Int_filter_validation of var
    (** Represents the validation of filters for an integer under lookup.  If
        the variable matches our lookup variable, only the `int' filter on the
        positive set is admissible and anything but `int' in the negative
        filters is admissible and can be erased. *)
    | Bool_filter_validation of var * bool
    (** Represents the validation of filters for Boolean values under lookup.  If
        the variable matches our lookup variable, only the `true'/`false' filter on the
        positive set is admissible and anything but `true'/`false' in the negative
        filters is admissible and can be erased. *)
    | String_filter_validation of var
    (** Represents the validation of filters for String values under lookup.  If
        the variable matches our lookup variable, only the `string' filter on the
        positive set is admissible and anything but `string' in the negative
        filters is admissible and can be erased. *)
    | Empty_record_value_discovery of var
    (** Represents the discovery of an empty record value assuming that the
        current lookup variable matches the one provided here. *)
    | Dereference_lookup of var * var
    (** Represents a dereferencing action.  The first variable is the lookup
        variable; the second variable is the variable it dereferences. *)
    | Cell_filter_validation of var * ref_value
    (** Represents the validation of filters for a cell under lookup.  If
        the variable matches our lookup variable, the cell (provided as the
        given abstract value) is pushed in its place. *)
    | Cell_dereference_1_of_2
    (** Represents the first step of dereferencing a located cell.  This is
        a stack reduction operation: the dereferenced cell must be on the
        value stack. *)
    | Cell_dereference_2_of_2 of ref_value
    (** Represents the second step of dereferencing a located cell.  The
        provided value is the cell in question. *)
    | Cell_update_alias_analysis_init_1_of_2 of var * pds_state * pds_state
    (** Represents the initialization of alias analysis for a given cell
        update.  This is used to determine if the update in question is
        modifying a cell for which we are looking via a different name.  The
        variable here is the cell being updated; the states are the source and
        target state of the original transition, respectively. *)
    | Cell_update_alias_analysis_init_2_of_2 of
        var * pds_state * pds_state * var * Pattern_set.t * Pattern_set.t
    (** Represents the second step of alias analysis initialization for a cell
        update.  The additional parameters are the contents of the
        continuation found during the first step. *)
    | Alias_analysis_resolution_1_of_5 of var
    (** Represents the final step of alias analysis which determines whether
        a cell may be an alias of the one currently under lookup.  The
        variable here is the name of the contents of the cell under
        consideration. *)
    | Alias_analysis_resolution_2_of_5 of var
    (** Alias analysis resolution after consuming the alias question from
        the stack. *)
    | Alias_analysis_resolution_3_of_5 of var * abstract_value
    (** Alias analysis resolution after consuming the first abstract value
        from the stack. *)
    | Alias_analysis_resolution_4_of_5 of var * bool
    (** Alias analysis resolution after consuming the second abstract value
        from the stack.  The boolean indicates whether the two abstract values
        were equal. *)
    | Alias_analysis_resolution_5_of_5 of
        var * bool * var * Pattern_set.t * Pattern_set.t
    (** Alias analysis resolution after consuming the lookup variable from the
        stack.  The additional elements here are the components of the lookup
        continuation. *)
    | Nonsideeffecting_nonmatching_clause_skip of var
    (** Represents the skip of a non-matching, non-stateful clause.  Although
        the rules indicate that this step should occur only when a deref
        exists on the stack, the rule overlaps with the stateless nonmatching
        clause skip in each occasion that a deref is not present.  So we
        simply drop that requirement here, as the overlap does not present
        a problem and it reduces the number of steps involved in performing
        this task.  The associated variable is the variable that a lookup must
        *not* match to be able to skip the clause. *)
    | Side_effect_search_init_1_of_2 of
        var * annotated_clause * C.t
    (** Represents the initialization of a search for side effects.  The
        provided variable must *not* be the lookup variable (since we'd be
        looking for an immediate definition in that case).  The clause and
        context represent the starting point of the side-effect search. *)
    | Side_effect_search_init_2_of_2 of
        var * Pattern_set.t * Pattern_set.t * annotated_clause * C.t
    (** Represents the initialization of a search for side effects.  At this
        point, all work has been performed except (1) validating the presence
        of a deref and (2) pushing the appropriate lookup continuations onto
        the stack. *)
    | Side_effect_search_nonmatching_clause_skip
    (** Represents the action of skipping any immediate, unannotated,
        non-update clause while searching for side effects. *)
    | Side_effect_search_exit_wiring
    (** Represents the action of moving into an exit wiring node during a
        side-effect search. *)
    | Side_effect_search_enter_wiring
    (** Represents the action of moving into an entrance wiring node during a
        side-effect search. *)
    | Side_effect_search_without_discovery
    (** Represents the end of a side-effect search which did not discover any
        relevant side effects. *)
    | Side_effect_search_alias_analysis_init of var * annotated_clause * C.t
    (** Represents the initialization of alias analysis for a cell update
        while in a side-effect search.  The variable is the cell being
        updated; the clause and context designate the state at which the
        alias analysis began. *)
    | Side_effect_search_alias_analysis_resolution_1_of_4 of var
    (** Represents the resolution of an alias analysis within a side-effect
        lookup.  The variable is the one being assigned to the cell. *)
    | Side_effect_search_alias_analysis_resolution_2_of_4 of var
    (** The second step of alias analysis resolution in a side-effect search.
        This step has consumed the "Alias?" question. *)
    | Side_effect_search_alias_analysis_resolution_3_of_4 of
        var * abstract_value
    (** The third step of alias analysis resolution in a side-effect search.
        The first abstract value has been consumed. *)
    | Side_effect_search_alias_analysis_resolution_4_of_4 of var * bool
    (** The last step of alias analysis resolution in a side-effect search.
        The variable is the one being assigned to a cell; the boolean
        indicates whether the particular value pair discovered here indicates
        aliasing or not. *)
    | Side_effect_search_escape_1_of_2
    (** The first step of processing a side-effect search escape.  This is
        used when the alias analysis of a cell update during a side-effect
        search successfully identifies a possible aliasing of the cell we are
        attempting to dereference.  This process is used to eliminate the
        stack frames which represent the side-effect search portion of the
        overall analysis so that lookup can proceed from the point at which
        the alias update is found. *)
    | Side_effect_search_escape_2_of_2 of var
    (** The second step of processing a side-effect search escape.  The
        variable is the one which was found to be the new value of the cell
        being dereferenced. *)
    | Side_effect_search_escape_completion_1_of_4
    (** Represents the completion of a side-effect search escape. *)
    | Side_effect_search_escape_completion_2_of_4 of var
    (** Represents the completion of a side-effect search escape.  The given
        variable is the one to which the aliased cell is being assigned. *)
    | Side_effect_search_escape_completion_3_of_4 of var
    (** Represents the completion of a side-effect search escape.  The given
        variable is the one to which the aliased cell is being assigned. *)
    | Side_effect_search_escape_completion_4_of_4 of var
    (** Represents the completion of a side-effect search escape.  The given
        variable is the one to which the aliased cell is being assigned. *)
    | Binary_operator_lookup_init of
        var * var * var * annotated_clause * C.t * annotated_clause * C.t
    (** Represents the kickstart of a process which looks up values for a
        binary operation.  The first variable above must be the
        current target of lookup.  The next two variables are the operands
        of the operation.  The remaining two pairs of values represent the
        source and target states of the DDPA edge. *)
    | Unary_operator_lookup_init of
        var * var * annotated_clause * C.t
    (** Represents the kickstart of a process which looks up values for a
        unary operation.  The first variable above must be the
        current target of lookup.  The second variable is the operand
        of the operation.  The state is the source states of the DDPA edge. *)
    | Indexing_lookup_init of
        var * var * var * annotated_clause * C.t * annotated_clause * C.t
    (** Represents the kickstart of a process which looks up values for
        indexing.  The first variable above must be the
        current target of lookup.  The next two variables are the subject
        and the index, respectively.  The remaining two pairs of values represent the
        source and target states of the DDPA edge. *)
    | Binary_operator_resolution_1_of_4 of var * binary_operator
    (** Represents the start of the resolution of a binary operator after its
        operands have been found.  The variable here is the one under
        lookup. *)
    | Binary_operator_resolution_2_of_4 of var * binary_operator
    (** The second step of binary operator resolution.  This step collects the
        first operand if it is a valid operand for the given kind of
        operation. *)
    | Binary_operator_resolution_3_of_4 of var * binary_operator * abstract_value
    (** The third step of binary operator resolution.  This step
        collects the second operand.  The `abstract_value' is the first operand
        accumulated on the previous step. *)
    | Binary_operator_resolution_4_of_4 of var * binary_operator * abstract_value
    (** The forth step of binary operator resolution.  This step
        collects and checks the lookup variable. The `abstract_value' is
        the result of the operation. A check guarantees that the given result
        is valid for the given operation. *)
    | Unary_operator_resolution_1_of_3 of var * unary_operator
    (** Represents the start of the resolution of a unary operator after its
        operands have been found.  The variable here is the one under
        lookup. *)
    | Unary_operator_resolution_2_of_3 of var * unary_operator
    (** The second step of unary operator resolution.  This step collects the
        operand if it is a valid operand for the given kind of
        operation. *)
    | Unary_operator_resolution_3_of_3 of var * unary_operator * abstract_value
    (** The third step of binary operator resolution.  This step
        collects and checks the lookup variable. The `abstract_value' is
        the result of the operation. A check guarantees that the given result
        is valid for the given operation. *)
    | Indexing_resolution_1_of_4 of var
    (** Represents the start of the resolution of indexing after its
        operands have been found.  The variable here is the one under
        lookup. *)
    | Indexing_resolution_2_of_4 of var
    (** The second step of binary operator resolution.  This step
        collects the index. *)
    | Indexing_resolution_3_of_4 of var
    (** The third step of binary operator resolution.  This step
        collects the subject. *)
    | Indexing_resolution_4_of_4 of var * abstract_value
    (** The forth step of binary operator resolution.  This step
        collects and checks the lookup variable. The `abstract_value' is
        the result of the operation. A check guarantees that the given result
        is valid for the given operation. *)
    [@@deriving ord]
  ;;

  let pp_pds_targeted_dynamic_pop_action action =
    match action with
    | Value_drop -> "Value_drop"
    | Value_discovery_2_of_2 -> "Value_discovery_2_of_2"
    | Variable_aliasing(x,x') ->
      Printf.sprintf "Variable_aliasing(%s,%s)" (pp_var x) (pp_var x')
    | Stateless_nonmatching_clause_skip_1_of_2(x) ->
      Printf.sprintf "Stateless_nonmatching_clause_skip_1_of_2(%s)"
        (pp_var x)
    | Stateless_nonmatching_clause_skip_2_of_2(k) ->
      Printf.sprintf "Stateless_nonmatching_clause_skip_2_of_2(%s)"
        (pp_pds_continuation k)
    | Value_capture_1_of_3 -> "Value_capture_1_of_3"
    | Value_capture_2_of_3(v) ->
      Printf.sprintf "Value_capture_1_of_2(%s)" (pp_abs_filtered_value v)
    | Value_capture_3_of_3(v,elements,size) ->
      Printf.sprintf "Value_capture_2_of_2(%s,%s,%d)"
        (pp_abs_filtered_value v) (pp_list pp_pds_continuation elements)
        (int_of_bounded_capture_size size)
    | Function_call_flow_validation(x_func,x_arg,acl0,ctx0,c,ctxc,x_site) ->
      Printf.sprintf "Function_call_flow_validation(%s,%s,%s,%s,%s,%s,%s)"
        (pp_var x_func) (pp_var x_arg) (pp_annotated_clause acl0) (C.pp ctx0)
        (pp_annotated_clause c) (C.pp ctxc) (pp_var x_site)
    | Function_call_flow_validation_resolution_1_of_2(x,x') ->
      Printf.sprintf "Function_call_flow_validation_resolution_1_of_2(%s,%s)"
        (pp_var x) (pp_var x')
    | Function_call_flow_validation_resolution_2_of_2(x,x') ->
      Printf.sprintf "Function_call_flow_validation_resolution_2_of_2(%s,%s)"
        (pp_var x) (pp_var x')
    | Function_closure_lookup(x'',xf) ->
      Printf.sprintf "Function_closure_lookup(%s,%s)"
        (pp_var x'') (pp_var xf)
    | Conditional_closure_lookup(x'',x1,p,b) ->
      Printf.sprintf "Conditional_closure_lookup(%s,%s,%s,%b)"
        (pp_var x'') (pp_var x1) (pp_pattern p) b
    | Conditional_subject_validation(x,x',x1,pat,then_branch,acl1,ctx) ->
      Printf.sprintf "Conditional_subject_validation(%s,%s,%s,%s,%s,%s,%s)"
        (pp_var x) (pp_var x') (pp_var x1) (pp_pattern pat)
        (string_of_bool then_branch) (pp_annotated_clause acl1) (C.pp ctx)
    | Record_projection_lookup(x,x',l) ->
      Printf.sprintf "Record_projection_lookup(%s,%s,%s)"
        (pp_var x) (pp_var x') (pp_ident l)
    | Record_projection_1_of_2 -> "Record_projection_1_of_2"
    | Record_projection_2_of_2(r,patsp,patsn) ->
      Printf.sprintf "Record_projection_2_of_2(%s,%s,%s)"
        (pp_record_value r) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Function_filter_validation(x,v) ->
      Printf.sprintf "Function_filter_validation(%s,%s)"
        (pp_var x) (pp_abstract_function_value v)
    | Record_filter_validation(x,r,acl1,ctx1) ->
      Printf.sprintf "Record_filter_validation(%s,%s,%s,%s)"
        (pp_var x) (pp_record_value r)
        (pp_annotated_clause acl1) (C.pp ctx1)
    | Int_filter_validation(x) ->
      Printf.sprintf "Int_filter_validation(%s)"
        (pp_var x)
    | Bool_filter_validation(x,b) ->
      Printf.sprintf "Bool_filter_validation(%s,%s)"
        (pp_var x) (string_of_bool b)
    | String_filter_validation(x) ->
      Printf.sprintf "String_filter_validation(%s)"
        (pp_var x)
    | Empty_record_value_discovery(x) ->
      Printf.sprintf "Empty_record_value_discovery(%s)" (pp_var x)
    | Dereference_lookup(x,x') ->
      Printf.sprintf "Dereference_lookup(%s,%s)" (pp_var x) (pp_var x')
    | Cell_filter_validation(x,cell) ->
      Printf.sprintf "Cell_filter_validation(%s,%s)"
        (pp_var x) (pp_ref_value cell)
    | Cell_dereference_1_of_2 -> "Cell_dereference_1_of_2"
    | Cell_dereference_2_of_2(cell) ->
      Printf.sprintf "Cell_dereference_2_of_2(%s)" (pp_ref_value cell)
    | Cell_update_alias_analysis_init_1_of_2(x',s1,s2) ->
      Printf.sprintf "Cell_update_alias_analysis_init_1_of_2(%s,%s,%s)"
        (pp_var x') (pp_pds_state s1) (pp_pds_state s2)
    | Cell_update_alias_analysis_init_2_of_2(x',s1,s2,x,patsp,patsn) ->
      Printf.sprintf "Cell_update_alias_analysis_init_2_of_2(%s,%s,%s,%s,%s,%s)"
        (pp_var x') (pp_pds_state s1) (pp_pds_state s2)
        (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Alias_analysis_resolution_1_of_5(x'') ->
      Printf.sprintf "AAR1(%s)" (pp_var x'')
    | Alias_analysis_resolution_2_of_5(x'') ->
      Printf.sprintf "AAR2(%s)" (pp_var x'')
    | Alias_analysis_resolution_3_of_5(x'',v) ->
      Printf.sprintf "AAR3(%s,%s)"
        (pp_var x'') (pp_abstract_value v)
    | Alias_analysis_resolution_4_of_5(x'',b) ->
      Printf.sprintf "AAR4(%s,%s)"
        (pp_var x'') (string_of_bool b)
    | Alias_analysis_resolution_5_of_5(x'',b,x,patsp,patsn) ->
      Printf.sprintf "AAR5(%s,%s,%s,%s,%s)"
        (pp_var x'') (string_of_bool b) (pp_var x)
        (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Nonsideeffecting_nonmatching_clause_skip(x'') ->
      Printf.sprintf "Nonsideeffecting_nonmatching_clause_skip(%s)"
        (pp_var x'')
    | Side_effect_search_init_1_of_2(x,acl0,ctx) ->
      Printf.sprintf "Side_effect_search_init_1_of_2(%s,%s,%s)"
        (pp_var x) (pp_annotated_clause acl0) (C.pp ctx)
    | Side_effect_search_init_2_of_2(x,patsp,patsn,acl0,ctx) ->
      Printf.sprintf "Side_effect_search_init_2_of_2(%s,%s,%s,%s,%s)"
        (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
        (pp_annotated_clause acl0) (C.pp ctx)
    | Side_effect_search_nonmatching_clause_skip ->
      "Side_effect_search_nonmatching_clause_skip"
    | Side_effect_search_exit_wiring ->
      "Side_effect_search_exit_wiring"
    | Side_effect_search_enter_wiring ->
      "Side_effect_search_enter_wiring"
    | Side_effect_search_without_discovery ->
      "Side_effect_search_without_discovery"
    | Side_effect_search_alias_analysis_init(x',acl,ctx) ->
      Printf.sprintf "Side_effect_search_alias_analysis_init(%s,%s,%s)"
        (pp_var x') (pp_annotated_clause acl) (C.pp ctx)
    | Side_effect_search_alias_analysis_resolution_1_of_4 x'' ->
      Printf.sprintf "Side_effect_search_alias_analysis_resolution_1_of_4(%s)"
        (pp_var x'')
    | Side_effect_search_alias_analysis_resolution_2_of_4(x'') ->
      Printf.sprintf "Side_effect_search_alias_analysis_resolution_2_of_4(%s)"
        (pp_var x'')
    | Side_effect_search_alias_analysis_resolution_3_of_4(x'',v) ->
      Printf.sprintf
        "Side_effect_search_alias_analysis_resolution_3_of_4(%s,%s)"
        (pp_var x'') (pp_abstract_value v)
    | Side_effect_search_alias_analysis_resolution_4_of_4(x'',is_alias) ->
      Printf.sprintf
        "Side_effect_search_alias_analysis_resolution_4_of_4(%s,%s)"
        (pp_var x'') (string_of_bool is_alias)
    | Side_effect_search_escape_1_of_2 ->
      "Side_effect_search_escape_1_of_2"
    | Side_effect_search_escape_2_of_2 x'' ->
      Printf.sprintf "Side_effect_search_escape_2_of_2(%s)" (pp_var x'')
    | Side_effect_search_escape_completion_1_of_4 ->
      "Side_effect_search_escape_completion_1_of_4"
    | Side_effect_search_escape_completion_2_of_4 x ->
      Printf.sprintf "Side_effect_search_escape_completion_2_of_4(%s)"
        (pp_var x)
    | Side_effect_search_escape_completion_3_of_4 x ->
      Printf.sprintf "Side_effect_search_escape_completion_3_of_4(%s)"
        (pp_var x)
    | Side_effect_search_escape_completion_4_of_4 x ->
      Printf.sprintf "Side_effect_search_escape_completion_4_of_4(%s)"
        (pp_var x)
    | Binary_operator_lookup_init(x1,x2,x3,acl1,ctx1,acl0,ctx0) ->
      Printf.sprintf "Binary_operator_lookup_init(%s,%s,%s,%s,%s,%s,%s)"
        (pp_var x1) (pp_var x2) (pp_var x3)
        (pp_annotated_clause acl1) (C.pp ctx1)
        (pp_annotated_clause acl0) (C.pp ctx0)
    | Unary_operator_lookup_init(x1,x2,acl0,ctx0) ->
      Printf.sprintf "Unary_operator_lookup_init(%s,%s,%s,%s)"
        (pp_var x1) (pp_var x2)
        (pp_annotated_clause acl0) (C.pp ctx0)
    | Indexing_lookup_init(x1,x2,x3,acl1,ctx1,acl0,ctx0) ->
      Printf.sprintf "Indexing_lookup_init(%s,%s,%s,%s,%s,%s,%s)"
        (pp_var x1) (pp_var x2) (pp_var x3)
        (pp_annotated_clause acl1) (C.pp ctx1)
        (pp_annotated_clause acl0) (C.pp ctx0)
    | Binary_operator_resolution_1_of_4(x1,op) ->
      Printf.sprintf "Binary_operator_resolution_1_of_4(%s,%s)"
        (pp_var x1) (pp_binary_operator op)
    | Binary_operator_resolution_2_of_4(x1,op) ->
      Printf.sprintf "Binary_operator_resolution_2_of_4(%s,%s)"
        (pp_var x1) (pp_binary_operator op)
    | Binary_operator_resolution_3_of_4(x1,op,abstract_value) ->
      Printf.sprintf "Binary_operator_resolution_3_of_4(%s,%s,%s)"
        (pp_var x1) (pp_binary_operator op) (pp_abstract_value abstract_value)
    | Binary_operator_resolution_4_of_4(x1,op,abstract_value) ->
      Printf.sprintf "Binary_operator_resolution_4_of_4(%s,%s,%s)"
        (pp_var x1) (pp_binary_operator op) (pp_abstract_value abstract_value)
    | Unary_operator_resolution_1_of_3(x1,op) ->
      Printf.sprintf "Unary_operator_resolution_1_of_3(%s,%s)"
        (pp_var x1) (pp_unary_operator op)
    | Unary_operator_resolution_2_of_3(x1,op) ->
      Printf.sprintf "Unary_operator_resolution_2_of_3(%s,%s)"
        (pp_var x1) (pp_unary_operator op)
    | Unary_operator_resolution_3_of_3(x1,op,abstract_value) ->
      Printf.sprintf "Unary_operator_resolution_3_of_3(%s,%s,%s)"
        (pp_var x1) (pp_unary_operator op) (pp_abstract_value abstract_value)
    | Indexing_resolution_1_of_4(x1) ->
      Printf.sprintf "Indexing_resolution_1_of_4(%s)"
        (pp_var x1)
    | Indexing_resolution_2_of_4(x1) ->
      Printf.sprintf "Indexing_resolution_2_of_4(%s)"
        (pp_var x1)
    | Indexing_resolution_3_of_4(x1) ->
      Printf.sprintf "Indexing_resolution_3_of_4(%s)"
        (pp_var x1)
    | Indexing_resolution_4_of_4(x1,abstract_value) ->
      Printf.sprintf "Indexing_resolution_4_of_4(%s,%s)"
        (pp_var x1) (pp_abstract_value abstract_value)
  ;;

  let ppa_pds_targeted_dynamic_pop_action action =
    match action with
    | Value_drop -> "ValDrop"
    | Value_discovery_2_of_2 -> "ValDisc2"
    | Variable_aliasing(x,x') ->
      Printf.sprintf "VAlias(%s,%s)" (pp_var x) (pp_var x')
    | Stateless_nonmatching_clause_skip_1_of_2(x) ->
      Printf.sprintf "SNMCS1(%s)"
        (pp_var x)
    | Stateless_nonmatching_clause_skip_2_of_2(k) ->
      Printf.sprintf "SNMCS2(%s)"
        (ppa_pds_continuation k)
    | Value_capture_1_of_3 -> "VCap1"
    | Value_capture_2_of_3(v) ->
      Printf.sprintf "VCap2(%s)" (pp_abs_filtered_value v)
    | Value_capture_3_of_3(v,elements,size) ->
      Printf.sprintf "VCap3(%s,%s,%d)"
        (pp_abs_filtered_value v) (pp_list ppa_pds_continuation elements)
        (int_of_bounded_capture_size size)
    | Function_call_flow_validation(x_func,x_arg,acl0,ctx0,c,ctxc,x_site) ->
      Printf.sprintf "FCFV(%s,%s,%s,%s,%s,%s,%s)"
        (pp_var x_func) (pp_var x_arg) (pp_annotated_clause acl0) (C.pp ctx0)
        (pp_annotated_clause c) (C.pp ctxc) (pp_var x_site)
    | Function_call_flow_validation_resolution_1_of_2(x,x') ->
      Printf.sprintf "FCFVR1(%s,%s)"
        (pp_var x) (pp_var x')
    | Function_call_flow_validation_resolution_2_of_2(x,x') ->
      Printf.sprintf "FCFVR2(%s,%s)"
        (pp_var x) (pp_var x')
    | Function_closure_lookup(x'',xf) ->
      Printf.sprintf "FunCL(%s,%s)"
        (pp_var x'') (pp_var xf)
    | Conditional_closure_lookup(x'',x1,p,b) ->
      Printf.sprintf "CondCL(%s,%s,%s,%b)"
        (pp_var x'') (pp_var x1) (pp_pattern p) b
    | Conditional_subject_validation(x,x',x1,pat,then_branch,acl1,ctx) ->
      Printf.sprintf "CondSV(%s,%s,%s,%s,%s,%s,%s)"
        (pp_var x) (pp_var x') (pp_var x1) (pp_pattern pat)
        (string_of_bool then_branch) (ppa_annotated_clause acl1) (C.pp ctx)
    | Record_projection_lookup(x,x',l) ->
      Printf.sprintf "RProjL(%s,%s,%s)"
        (pp_var x) (pp_var x') (pp_ident l)
    | Record_projection_1_of_2 -> "RProj1"
    | Record_projection_2_of_2(r,patsp,patsn) ->
      Printf.sprintf "RProj2(%s,%s,%s)"
        (pp_record_value r) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Function_filter_validation(x,f) ->
      Printf.sprintf "FunFilVal(%s,%s)"
        (pp_var x) (pp_abstract_function_value f)
    | Record_filter_validation(x,r,acl1,ctx1) ->
      Printf.sprintf "RecFilVal(%s,%s,%s,%s)"
        (pp_var x) (pp_record_value r)
        (pp_annotated_clause acl1) (C.pp ctx1)
    | Int_filter_validation(x) ->
      Printf.sprintf "IntFilVal(%s)"
        (pp_var x)
    | Bool_filter_validation(x,b) ->
      Printf.sprintf "BoolFilVal(%s,%s)"
        (pp_var x) (string_of_bool b)
    | String_filter_validation(x) ->
      Printf.sprintf "StringFilVal(%s)"
        (pp_var x)
    | Empty_record_value_discovery(x) ->
      Printf.sprintf "ERValDisc(%s)" (pp_var x)
    | Dereference_lookup(x,x') ->
      Printf.sprintf "Deref(%s,%s)" (pp_var x) (pp_var x')
    | Cell_filter_validation(x,cell) ->
      Printf.sprintf "CellFilVal(%s,%s)" (pp_var x) (pp_ref_value cell)
    | Cell_dereference_1_of_2 -> "CDr1"
    | Cell_dereference_2_of_2(cell) ->
      Printf.sprintf "CDr2(%s)" (pp_ref_value cell)
    | Cell_update_alias_analysis_init_1_of_2(x',s1,s2) ->
      Printf.sprintf "CUAA1(%s,%s,%s)"
        (pp_var x') (pp_pds_state s1) (pp_pds_state s2)
    | Cell_update_alias_analysis_init_2_of_2(x',s1,s2,x,patsp,patsn) ->
      Printf.sprintf "CUAA2(%s,%s,%s,%s,%s,%s)"
        (pp_var x') (pp_pds_state s1) (pp_pds_state s2)
        (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Alias_analysis_resolution_1_of_5(x'') ->
      Printf.sprintf "AAR1(%s)" (pp_var x'')
    | Alias_analysis_resolution_2_of_5(x'') ->
      Printf.sprintf "AAR2(%s)" (pp_var x'')
    | Alias_analysis_resolution_3_of_5(x'',v) ->
      Printf.sprintf "AAR3(%s,%s)"
        (pp_var x'') (pp_abstract_value v)
    | Alias_analysis_resolution_4_of_5(x'',b) ->
      Printf.sprintf "AAR4(%s,%s)"
        (pp_var x'') (string_of_bool b)
    | Alias_analysis_resolution_5_of_5(x'',b,x,patsp,patsn) ->
      Printf.sprintf "AAR5(%s,%s,%s,%s,%s)"
        (pp_var x'') (string_of_bool b) (pp_var x)
        (pp_pattern_set patsp) (pp_pattern_set patsn)
    | Nonsideeffecting_nonmatching_clause_skip(x'') ->
      Printf.sprintf "NNCS(%s)" (pp_var x'')
    | Side_effect_search_init_1_of_2(x,acl0,ctx) ->
      Printf.sprintf "SESI1(%s,%s,%s)"
        (pp_var x) (ppa_annotated_clause acl0) (C.pp ctx)
    | Side_effect_search_init_2_of_2(x,patsp,patsn,acl0,ctx) ->
      Printf.sprintf "SESI2(%s,%s,%s,%s,%s)"
        (pp_var x) (pp_pattern_set patsp) (pp_pattern_set patsn)
        (ppa_annotated_clause acl0) (C.pp ctx)
    | Side_effect_search_nonmatching_clause_skip -> "SESNCS"
    | Side_effect_search_exit_wiring -> "SESXW"
    | Side_effect_search_enter_wiring -> "SESEW"
    | Side_effect_search_without_discovery -> "SESWD"
    | Side_effect_search_alias_analysis_init(x',acl,ctx) ->
      Printf.sprintf "SESAAI(%s,%s,%s)"
        (pp_var x') (pp_annotated_clause acl) (C.pp ctx)
    | Side_effect_search_alias_analysis_resolution_1_of_4 x'' ->
      Printf.sprintf "SESAAR1(%s)"
        (pp_var x'')
    | Side_effect_search_alias_analysis_resolution_2_of_4(x'') ->
      Printf.sprintf "SESAAR2(%s)" (pp_var x'')
    | Side_effect_search_alias_analysis_resolution_3_of_4(x'',v) ->
      Printf.sprintf "SESAAR3(%s,%s)"
        (pp_var x'') (pp_abstract_value v)
    | Side_effect_search_alias_analysis_resolution_4_of_4(x'',is_alias) ->
      Printf.sprintf "SESAAR4(%s,%s)"
        (pp_var x'') (string_of_bool is_alias)
    | Side_effect_search_escape_1_of_2 -> "SESE1"
    | Side_effect_search_escape_2_of_2 x'' ->
      Printf.sprintf "SESE2(%s)" (pp_var x'')
    | Side_effect_search_escape_completion_1_of_4 -> "SESEC1"
    | Side_effect_search_escape_completion_2_of_4 x ->
      Printf.sprintf "SESEC2(%s)" (pp_var x)
    | Side_effect_search_escape_completion_3_of_4 x ->
      Printf.sprintf "SESEC3(%s)" (pp_var x)
    | Side_effect_search_escape_completion_4_of_4 x ->
      Printf.sprintf "SESEC4(%s)" (pp_var x)
    | Binary_operator_lookup_init(x1,x2,x3,acl1,ctx1,acl0,ctx0) ->
      Printf.sprintf "BinOpInit(%s,%s,%s,%s,%s,%s,%s)"
        (pp_var x1) (pp_var x2) (pp_var x3)
        (ppa_annotated_clause acl1) (C.pp ctx1)
        (ppa_annotated_clause acl0) (C.pp ctx0)
    | Unary_operator_lookup_init(x1,x2,acl0,ctx0) ->
      Printf.sprintf "UnOpInit(%s,%s,%s,%s)"
        (pp_var x1) (pp_var x2)
        (ppa_annotated_clause acl0) (C.pp ctx0)
    | Indexing_lookup_init(x1,x2,x3,acl1,ctx1,acl0,ctx0) ->
      Printf.sprintf "IdxOpInit(%s,%s,%s,%s,%s,%s,%s)"
        (pp_var x1) (pp_var x2) (pp_var x3)
        (ppa_annotated_clause acl1) (C.pp ctx1)
        (ppa_annotated_clause acl0) (C.pp ctx0)
    | Binary_operator_resolution_1_of_4(x1,op) ->
      Printf.sprintf "BinOpRes1(%s,%s)" (pp_var x1) (pp_binary_operator op)
    | Binary_operator_resolution_2_of_4(x1,op) ->
      Printf.sprintf "BinOpRes2(%s,%s)" (pp_var x1) (pp_binary_operator op)
    | Binary_operator_resolution_3_of_4(x1,op,abstract_value) ->
      Printf.sprintf "BinOpRes3(%s,%s,%s)" (pp_var x1) (pp_binary_operator op)
        (pp_abstract_value abstract_value)
    | Binary_operator_resolution_4_of_4(x1,op,abstract_value) ->
      Printf.sprintf "BinOpRes4(%s,%s,%s)" (pp_var x1) (pp_binary_operator op)
        (pp_abstract_value abstract_value)
    | Unary_operator_resolution_1_of_3(x1,op) ->
      Printf.sprintf "UnOpRes1(%s,%s)" (pp_var x1) (pp_unary_operator op)
    | Unary_operator_resolution_2_of_3(x1,op) ->
      Printf.sprintf "UnOpRes2(%s,%s)" (pp_var x1) (pp_unary_operator op)
    | Unary_operator_resolution_3_of_3(x1,op,abstract_value) ->
      Printf.sprintf "UnOpRes3(%s,%s,%s)" (pp_var x1) (pp_unary_operator op)
        (pp_abstract_value abstract_value)
    | Indexing_resolution_1_of_4(x1) ->
      Printf.sprintf "BinOpRes1(%s)" (pp_var x1)
    | Indexing_resolution_2_of_4(x1) ->
      Printf.sprintf "BinOpRes2(%s)" (pp_var x1)
    | Indexing_resolution_3_of_4(x1) ->
      Printf.sprintf "BinOpRes3(%s)" (pp_var x1)
    | Indexing_resolution_4_of_4(x1,abstract_value) ->
      Printf.sprintf "BinOpRes4(%s,%s)" (pp_var x1)
        (pp_abstract_value abstract_value)
  ;;

  type pds_untargeted_dynamic_pop_action =
    | Do_jump
    (** The action for performing basic jump operations. *)
    | Value_discovery_1_of_2
    (** Represents the rule that, if a value is the only element on the stack,
        we transition to one of the result states.  To determine that the
        value is the only element, we must be able to pop the special "bottom"
        stack element, so this is the first step of the process (which pops
        the value).  Because the value dictates the target of the second
        step, this is an untargeted action.  The second step is targeted. *)
    [@@deriving ord]
  ;;

  let pp_pds_untargeted_dynamic_pop_action action =
    match action with
    | Do_jump -> "Do_jump"
    | Value_discovery_1_of_2 -> "VDisc1"
  ;;

  let ppa_pds_untargeted_dynamic_pop_action action =
    match action with
    | Do_jump -> "Do_jump"
    | Value_discovery_1_of_2 -> "VDisc1"
  ;;

  module Dph =
  struct
    type stack_element = pds_continuation;;
    type state = pds_state;;
    type targeted_dynamic_pop_action = pds_targeted_dynamic_pop_action;;
    type untargeted_dynamic_pop_action = pds_untargeted_dynamic_pop_action;;
    type stack_action =
      ( stack_element
      , targeted_dynamic_pop_action
      ) pds_stack_action
    ;;
    let compare_targeted_dynamic_pop_action =
      compare_pds_targeted_dynamic_pop_action;;
    let pp_targeted_dynamic_pop_action = pp_pds_targeted_dynamic_pop_action;;
    let ppa_targeted_dynamic_pop_action = ppa_pds_targeted_dynamic_pop_action;;
    let compare_untargeted_dynamic_pop_action =
      compare_pds_untargeted_dynamic_pop_action;;
    let pp_untargeted_dynamic_pop_action =
      pp_pds_untargeted_dynamic_pop_action;;
    let ppa_untargeted_dynamic_pop_action =
      ppa_pds_untargeted_dynamic_pop_action;;
    let perform_targeted_dynamic_pop element action =
      Logger_utils.lazy_bracket_log (lazy_logger `trace)
        (fun () ->
           Printf.sprintf "perform_targeted_dynamic_pop (%s) (%s)"
             (pp_pds_continuation element)
             (pp_pds_targeted_dynamic_pop_action action))
        (fun results ->
           String_utils.concat_sep_delim "[" "]" ", "
             (
               results
               |> Enum.clone
               |> Enum.map (String_utils.pp_list @@
                            pp_pds_stack_action pp_pds_continuation
                              pp_pds_targeted_dynamic_pop_action)
             )
        )
      @@ fun () ->
      Nondeterminism_monad.enum @@
      let open Nondeterminism_monad in
      match action with
      | Value_drop ->
        let%orzero Continuation_value _ = element in
        return []
      | Value_discovery_2_of_2 ->
        let%orzero Bottom_of_stack = element in
        return []
      | Variable_aliasing(x2,x1) ->
        let%orzero (Lookup_var(x',patsp,patsn)) = element in
        [%guard equal_var x' x2];
        (* We're looking for x2 and we've discovered here that it's aliased to
           x1. *)
        return [Push(Lookup_var(x1,patsp,patsn))]
      | Stateless_nonmatching_clause_skip_1_of_2 x'' ->
        let%orzero (Lookup_var(x,_,_)) = element in
        [%guard (not @@ equal_var x x'')];
        (* We're looking for a variable which does not match the one in this
           clause.  If we're stateless, that'll be fine. *)
        return [Pop_dynamic_targeted(
            Stateless_nonmatching_clause_skip_2_of_2 element)]
      | Stateless_nonmatching_clause_skip_2_of_2 element' ->
        begin
          match element with
          | Deref(_,_) ->
            (* This means we're in a stateful mode.  Stateless non-matching
               clause skip is inappropriate here. *)
            zero ()
          | _ ->
            (* We're not in a stateful mode, so we can skip the clause.  We
               still have to put these elements back on the stack, though. *)
            return [Push(element);Push(element')]
        end
      | Value_capture_1_of_3 ->
        let%orzero (Continuation_value abs_filtered_value) = element in
        return [ Pop_dynamic_targeted(
            Value_capture_2_of_3(abs_filtered_value)) ]
      | Value_capture_2_of_3 fv ->
        let%orzero Capture(size) = element in
        return [ Pop_dynamic_targeted(Value_capture_3_of_3(fv,[],size)) ]
      | Value_capture_3_of_3(fv,collected_elements,size) ->
        let n = int_of_bounded_capture_size size in
        if n > 1
        then
          begin
            let size' = make_bounded_capture_size (n-1) in
            return
              [Pop_dynamic_targeted
                 (Value_capture_3_of_3(fv,element::collected_elements,size'))]
          end
        else
          begin
            let pushes =
              List.map (fun x -> Push x) (element::collected_elements)
            in
            return @@ (Push (Continuation_value fv))::pushes
          end
      | Function_call_flow_validation(x2'',x3'',acl0,ctx0,c,ctxc,x) ->
        let%orzero (Lookup_var(x',_,_)) = element in
        [%guard (equal_var x x')];
        return [ Push(element)
               ; Push(Real_flow_huh)
               ; Push(Jump(acl0,ctx0))
               ; Push(Capture(make_bounded_capture_size 2))
               ; Push(Lookup_var(x2'',Pattern_set.empty,Pattern_set.empty))
               ; Push(Jump(c,ctxc))
               ; Push(Lookup_var(x3'',Pattern_set.empty,Pattern_set.empty))
               ]
      | Function_call_flow_validation_resolution_1_of_2(x,x') ->
        let%orzero Real_flow_huh = element in
        let action = Function_call_flow_validation_resolution_2_of_2(x,x') in
        return [ Pop_dynamic_targeted(action) ]
      | Function_call_flow_validation_resolution_2_of_2(x,x') ->
        let%orzero Continuation_value(v) = element in
        let Abs_filtered_value(v',_,_) = v in
        let%orzero
          Abs_value_function(Abs_function_value(_,Abs_expr(acls))) = v'
        in
        [%guard (equal_var x' @@ rv acls)];
        return [ Pop_dynamic_targeted(Variable_aliasing(x,x')) ]
      | Function_closure_lookup(x'',xf) ->
        let%orzero (Lookup_var(x,_,_)) = element in
        [%guard (not @@ equal_var x x'')];
        (* We're looking for a non-local variable.  Push a lookup for the
           function. *)
        return [ Push(element)
               ; Push(Lookup_var(xf,Pattern_set.empty,Pattern_set.empty))
               ]
      | Conditional_closure_lookup(x',x1,pat,positive_side) ->
        let%orzero (Lookup_var(x,patsp,patsn)) = element in
        if not @@ (equal_var x x' || equal_var x x1)
        then return [Push(element)]
        else
          let (patsp',patsn') =
            if positive_side
            then (Pattern_set.add pat patsp,patsn)
            else (patsp,Pattern_set.add pat patsn)
          in
          return [Push(Lookup_var(x1,patsp',patsn'))]
      | Conditional_subject_validation(x,x',x1,pat,then_branch,acl1,ctx) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [%guard (equal_var x0 x)];
        let patsp',patsn' =
          if then_branch
          then (Pattern_set.singleton pat, Pattern_set.empty)
          else (Pattern_set.empty, Pattern_set.singleton pat)
        in
        return [ Push(Lookup_var(x',patsp,patsn))
               ; Push(Jump(acl1,ctx))
               ; Push(Lookup_var(x1,patsp',patsn'))
               ]
      | Record_projection_lookup(x,x',l) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [%guard (equal_var x0 x)];
        return [ Push(Project(l,patsp,patsn))
               ; Push(Lookup_var(x',Pattern_set.empty,Pattern_set.empty))
               ]
      | Record_projection_1_of_2 ->
        let%orzero (Continuation_value fv) = element in
        let%orzero (Abs_filtered_value(Abs_value_record(r),patsp,patsn)) = fv in
        return [ Pop_dynamic_targeted(Record_projection_2_of_2(r,patsp,patsn)) ]
      | Record_projection_2_of_2(Record_value(m) as r,patsp0,patsn0) ->
        [%guard (is_record_pattern_set patsp0)];
        let%orzero (Project(l,patsp1,patsn1)) = element in
        [%guard (Ident_map.mem l m)];
        (* FIXME: the following isn't in the spec, but maybe it should be... just here to test things for now *)
        [% guard (not @@
                  Pattern_set.mem (Record_pattern Ident_map.empty) patsn0) ];
        let%bind patsn2 = negative_pattern_set_selection r patsn0 in
        let x' = Ident_map.find l m in
        let patsp' = Pattern_set.union patsp1 @@
          pattern_set_projection patsp0 l in
        let patsn' = Pattern_set.union patsn1 @@
          pattern_set_projection patsn2 l in
        return @@ [ Push(Lookup_var(x',patsp',patsn')) ]
      | Function_filter_validation(x,v) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [% guard (equal_var x x0) ];
        [% guard (Pattern_set.subset patsp (Pattern_set.singleton Fun_pattern)) ];
        [% guard (not @@ Pattern_set.mem Fun_pattern patsn) ];
        let value = Abs_value_function(v) in
        let abs_filtered_value =
          Abs_filtered_value(value,Pattern_set.empty,Pattern_set.empty)
        in
        return [ Push(Continuation_value abs_filtered_value) ]
      | Record_filter_validation(x,r,acl1,ctx1) ->
        (* Make sure we're looking for this variable. *)
        let%orzero (Lookup_var(x0,patsp0,patsn0)) = element in
        [% guard (equal_var x x0) ];
        [% guard (is_record_pattern_set patsp0)];
        (* FIXME: the following isn't in the spec, but maybe it should be... just here to test things for now *)
        [% guard (not @@
                  Pattern_set.mem (Record_pattern Ident_map.empty) patsn0) ];
        let%bind patsn2 = negative_pattern_set_selection r patsn0 in
        let pattern_set_labels = labels_in_pattern_set patsp0 in
        let record_labels = labels_in_record r in
        let Record_value(m) = r in
        [%guard (Ident_set.subset pattern_set_labels record_labels) ];
        let make_k'' l =
          let x'' = Ident_map.find l m in
          List.enum [ Push(Lookup_var( x''
                                     , pattern_set_projection patsp0 l
                                     , pattern_set_projection patsn2 l))
                    ; Push(Jump(acl1,ctx1))
                    ]
        in
        let first_pushes =
          List.enum [ Push(Continuation_value(Abs_filtered_value(
              Abs_value_record(r), patsp0, patsn2)))
                    ; Push(Jump(acl1,ctx1))
            ]
        in
        let all_pushes =
          record_labels
          |> Ident_set.enum
          |> Enum.map make_k''
          |> Enum.concat
          |> Enum.append first_pushes
        in
        return @@ List.of_enum all_pushes
      | Int_filter_validation(x) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [% guard (equal_var x x0) ];
        [% guard (Pattern_set.subset patsp (Pattern_set.singleton Int_pattern)) ];
        [% guard (not @@ Pattern_set.mem Int_pattern patsn) ];
        let abs_filtered_value =
          Abs_filtered_value(Abs_value_int,Pattern_set.empty,Pattern_set.empty)
        in
        return [ Push(Continuation_value abs_filtered_value) ]
      | Bool_filter_validation(x,b) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [% guard (equal_var x x0) ];
        [% guard (Pattern_set.subset patsp (Pattern_set.singleton (Bool_pattern(b)))) ];
        [% guard (not @@ Pattern_set.mem (Bool_pattern(b)) patsn) ];
        let abs_filtered_value =
          Abs_filtered_value(Abs_value_bool(b),Pattern_set.empty,Pattern_set.empty)
        in
        return [ Push(Continuation_value abs_filtered_value) ]
      | String_filter_validation(x) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [% guard (equal_var x x0) ];
        [% guard (Pattern_set.subset patsp (Pattern_set.singleton (String_pattern))) ];
        [% guard (not @@ Pattern_set.mem (String_pattern) patsn) ];
        let abs_filtered_value =
          Abs_filtered_value(Abs_value_string,Pattern_set.empty,Pattern_set.empty)
        in
        return [ Push(Continuation_value abs_filtered_value) ]
      | Empty_record_value_discovery(x) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [%guard (equal_var x x0)];
        let empty_record = Abs_value_record(Record_value Ident_map.empty) in
        let empty_record_pattern = Record_pattern Ident_map.empty in
        [% guard (Pattern_set.subset
                    patsp (Pattern_set.singleton empty_record_pattern)) ];
        [% guard (not @@ Pattern_set.mem empty_record_pattern patsn) ];
        return [ Push(Continuation_value(Abs_filtered_value(
            empty_record,Pattern_set.empty,Pattern_set.empty))) ]
      | Dereference_lookup(x,x') ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [% guard (equal_var x x0) ];
        return [ Push(Deref(patsp, patsn))
               ; Push(Lookup_var(x', Pattern_set.empty, Pattern_set.empty))
               ]
      | Cell_filter_validation(x,cell) ->
        let%orzero (Lookup_var(x0,patsp,patsn)) = element in
        [% guard (equal_var x x0) ];
        [% guard (Pattern_set.subset patsp (Pattern_set.singleton Ref_pattern)) ];
        [% guard (not @@ Pattern_set.mem Ref_pattern patsn) ];
        let value = Abs_value_ref(cell) in
        return [ Push(Continuation_value(Abs_filtered_value(
            value,Pattern_set.empty,Pattern_set.empty))) ]
      | Cell_dereference_1_of_2 ->
        let%orzero
          (Continuation_value(Abs_filtered_value(
               Abs_value_ref(cell),patsp,patsn))) = element
        in
        [% guard (Pattern_set.is_empty patsp) ];
        [% guard (Pattern_set.is_empty patsn) ];
        (* From here, we need another stack frame element to confirm the
           dereference action and obtain its filters. *)
        return [ Pop_dynamic_targeted(Cell_dereference_2_of_2(cell)) ]
      | Cell_dereference_2_of_2(cell) ->
        let%orzero (Deref(patsp,patsn)) = element in
        let Ref_value(x') = cell in
        return [ Push(Lookup_var(x', patsp, patsn)) ]
      | Cell_update_alias_analysis_init_1_of_2(x',source_state,target_state) ->
        let%orzero (Lookup_var(x,patsp,patsn)) = element in
        return [ Pop_dynamic_targeted(
            Cell_update_alias_analysis_init_2_of_2(
              x',source_state,target_state,x,patsp,patsn)) ]
      | Cell_update_alias_analysis_init_2_of_2(
          x',source_state,target_state,x,patsp0,patsn0) ->
        let%orzero (Deref _) = element in
        let%orzero Program_point_state(acl1,ctx1) = source_state in
        let%orzero Program_point_state(acl0,ctx0) = target_state in
        (* The lists below are in reverse order of their presentation in the
           formal rules because we are not directly modifying the stack;
           instead, we are pushing stack elements one at a time. *)
        let capture_size_5 = make_bounded_capture_size 5 in
        let capture_size_2 = make_bounded_capture_size 2 in
        let k1'' = [ Capture capture_size_5 ; Lookup_var(x,patsp0,patsn0) ] in
        let k2'' = [ Capture capture_size_2
                   ; Lookup_var(x',Pattern_set.empty,Pattern_set.empty)
                   ; Jump(acl1, ctx1) ] in
        let k3'' = [ Alias_huh ; Jump(acl0,ctx0) ] in
        let k0 = [ element ; Lookup_var(x,patsp0,patsn0) ] in
        return @@ List.map (fun x -> Push x) @@
        k0 @ k3'' @ k2'' @ k1''
      | Alias_analysis_resolution_1_of_5(x'') ->
        let%orzero Alias_huh = element in
        return [ Pop_dynamic_targeted
                   (Alias_analysis_resolution_2_of_5(x'')) ]
      | Alias_analysis_resolution_2_of_5(x'') ->
        let%orzero
          Continuation_value(Abs_filtered_value(v,patsp,patsn)) = element
        in
        [%guard (Pattern_set.is_empty patsp)];
        [%guard (Pattern_set.is_empty patsn)];
        return [ Pop_dynamic_targeted
                   (Alias_analysis_resolution_3_of_5(x'', v)) ]
      | Alias_analysis_resolution_3_of_5(x'',v) ->
        let%orzero
          Continuation_value(Abs_filtered_value(v',patsp,patsn)) = element
        in
        [%guard (Pattern_set.is_empty patsp)];
        [%guard (Pattern_set.is_empty patsn)];
        let equal_values = equal_abstract_value v v' in
        return [ Pop_dynamic_targeted
                   (Alias_analysis_resolution_4_of_5(x'',equal_values)) ]
      | Alias_analysis_resolution_4_of_5(x'',equal_values) ->
        let%orzero Lookup_var(x,patsp0,patsn0) = element in
        return [ Pop_dynamic_targeted
                   (Alias_analysis_resolution_5_of_5(
                       x'',equal_values,x,patsp0,patsn0)) ]
      | Alias_analysis_resolution_5_of_5(x'',equal_values,x,patsp0,patsn0) ->
        let%orzero Deref(patsp1,patsn1) = element in
        if equal_values
        then
          return [ Push(Lookup_var(x'',patsp1,patsn1)) ]
        else
          return [ Push(Deref(patsp1,patsn1))
                 ; Push(Lookup_var(x,patsp0,patsn0)) ]
      | Nonsideeffecting_nonmatching_clause_skip(x'') ->
        let%orzero Lookup_var(x,_,_) = element in
        [%guard (not @@ equal_var x x'')];
        return [Push element]
      | Side_effect_search_init_1_of_2(x'',acl0,ctx) ->
        let%orzero Lookup_var(x,patsp,patsn) = element in
        [%guard (not @@ equal_var x x'')];
        return [ Pop_dynamic_targeted(
            Side_effect_search_init_2_of_2(x,patsp,patsn,acl0,ctx)) ]
      | Side_effect_search_init_2_of_2(x,patsp,patsn,acl0,ctx) ->
        let%orzero Deref _ = element in
        return [ Push element ; Push (Lookup_var(x,patsp,patsn))
               ; Push Side_effect_search_start
               ; Push (Side_effect_lookup_var(x,patsp,patsn,acl0,ctx))
               ]
      | Side_effect_search_nonmatching_clause_skip ->
        let%orzero (Side_effect_lookup_var _) = element in
        return [ Push element ]
      | Side_effect_search_exit_wiring ->
        let%orzero (Side_effect_lookup_var _) = element in
        return [ Push element ; Push element ]
      | Side_effect_search_enter_wiring ->
        let%orzero (Side_effect_lookup_var _) = element in
        return []
      | Side_effect_search_without_discovery ->
        let%orzero Side_effect_search_start = element in
        return []
      | Side_effect_search_alias_analysis_init(x',acl0,ctx) ->
        let%orzero (Side_effect_lookup_var(x,patsp,patsn,acl',ctx')) =
          element
        in
        (* The following stack elements are "backwards" because they appear in
           the order in which they are pushed (similar to the other case of
           alias analysis initialization). *)
        let capture_size_5 = make_bounded_capture_size 5 in
        let capture_size_2 = make_bounded_capture_size 2 in
        let k1'' =
          [ Capture(capture_size_5)
          ; Lookup_var(x',Pattern_set.empty,Pattern_set.empty) ]
        in
        let k2'' =
          [ Capture(capture_size_2)
          ; Lookup_var(x,patsp,patsn)
          ; Jump(acl',ctx') ]
        in
        let k3'' =
          [ Alias_huh ; Jump(acl0, ctx) ]
        in
        return @@ List.map (fun x -> Push x) @@ [element] @ k3'' @ k2'' @ k1''
      | Side_effect_search_alias_analysis_resolution_1_of_4(x'') ->
        let%orzero Alias_huh = element in
        return [ Pop_dynamic_targeted (
            Side_effect_search_alias_analysis_resolution_2_of_4(x'')) ]
      | Side_effect_search_alias_analysis_resolution_2_of_4(x'') ->
        let%orzero
          Continuation_value(Abs_filtered_value(v,patsp,patsn)) = element
        in
        [%guard (Pattern_set.is_empty patsp) ];
        [%guard (Pattern_set.is_empty patsn) ];
        return [ Pop_dynamic_targeted (
            Side_effect_search_alias_analysis_resolution_3_of_4(x'',v)) ]
      | Side_effect_search_alias_analysis_resolution_3_of_4(x'',v1) ->
        let%orzero
          Continuation_value(Abs_filtered_value(v2,patsp,patsn)) = element
        in
        [%guard (Pattern_set.is_empty patsp) ];
        [%guard (Pattern_set.is_empty patsn) ];
        let is_alias = equal_abstract_value v1 v2 in
        return [ Pop_dynamic_targeted (
            Side_effect_search_alias_analysis_resolution_4_of_4(
              x'',is_alias)) ]
      | Side_effect_search_alias_analysis_resolution_4_of_4(x'',is_alias) ->
        let%orzero (Side_effect_lookup_var _) = element in
        if is_alias then
          (* 7g.ix *)
          return [ Push (Side_effect_search_escape x'') ]
        else
          (* 7g.viii *)
          return [ Push element ]
      | Side_effect_search_escape_1_of_2 ->
        let%orzero Side_effect_search_escape x'' = element in
        return [ Pop_dynamic_targeted (
            Side_effect_search_escape_2_of_2 x'') ]
      | Side_effect_search_escape_2_of_2 x'' ->
        let%orzero Side_effect_lookup_var _ = element in
        return [ Push (Side_effect_search_escape x'') ]
      | Side_effect_search_escape_completion_1_of_4 ->
        let%orzero Side_effect_search_escape x = element in
        return [ Pop_dynamic_targeted (
            Side_effect_search_escape_completion_2_of_4 x) ]
      | Side_effect_search_escape_completion_2_of_4 x ->
        let%orzero Side_effect_search_start = element in
        return [ Pop_dynamic_targeted (
            Side_effect_search_escape_completion_3_of_4 x) ]
      | Side_effect_search_escape_completion_3_of_4 x ->
        let%orzero Lookup_var _ = element in
        return [ Pop_dynamic_targeted (
            Side_effect_search_escape_completion_4_of_4 x) ]
      | Side_effect_search_escape_completion_4_of_4 x ->
        let%orzero Deref(patsp,patsn) = element in
        return [ Push (Lookup_var(x,patsp,patsn)) ]
      | Binary_operator_lookup_init(x1,x2,x3,acl1,ctx1,acl0,ctx0) ->
        let%orzero Lookup_var(x1',_,_) = element in
        [%guard (equal_var x1 x1') ];
        (* The lists below are in reverse order of their presentation in the
           formal rules because we are not directly modifying the stack;
           instead, we are pushing stack elements one at a time. *)
        let capture_size_5 = make_bounded_capture_size 5 in
        let capture_size_2 = make_bounded_capture_size 2 in
        let k1'' = [ Capture capture_size_5
                   ; Lookup_var(x2,Pattern_set.empty,Pattern_set.empty)
                   ] in
        let k2'' = [ Capture capture_size_2
                   ; Lookup_var(x3,Pattern_set.empty,Pattern_set.empty)
                   ; Jump(acl1, ctx1) ] in
        let k3'' = [ Binary_operation ; Jump(acl0,ctx0) ] in
        let k0 = [ element ] in
        return @@ List.map (fun x -> Push x) @@ k0 @ k3'' @ k2'' @ k1''
      | Unary_operator_lookup_init(x1,x2,acl0,ctx0) ->
        let%orzero Lookup_var(x1',_,_) = element in
        [%guard (equal_var x1 x1') ];
        (* The lists below are in reverse order of their presentation in the
           formal rules because we are not directly modifying the stack;
           instead, we are pushing stack elements one at a time. *)
        let capture_size_2 = make_bounded_capture_size 2 in
        let k1'' = [ Capture capture_size_2
                   ; Lookup_var(x2,Pattern_set.empty,Pattern_set.empty)
                   ] in
        let k2'' = [ Unary_operation ; Jump(acl0,ctx0) ] in
        let k0 = [ element ] in
        return @@ List.map (fun x -> Push x) @@ k0 @ k2'' @ k1''
      | Indexing_lookup_init(x1,x2,x3,acl1,ctx1,acl0,ctx0) ->
        let%orzero Lookup_var(x1',_,_) = element in
        [%guard (equal_var x1 x1') ];
        (* The lists below are in reverse order of their presentation in the
           formal rules because we are not directly modifying the stack;
           instead, we are pushing stack elements one at a time. *)
        let capture_size_5 = make_bounded_capture_size 5 in
        let capture_size_2 = make_bounded_capture_size 2 in
        let k1'' = [ Capture capture_size_5
                   ; Lookup_var(x2,Pattern_set.empty,Pattern_set.empty)
                   ] in
        let k2'' = [ Capture capture_size_2
                   ; Lookup_var(x3,Pattern_set.empty,Pattern_set.empty)
                   ; Jump(acl1, ctx1) ] in
        let k3'' = [ Indexing ; Jump(acl0,ctx0) ] in
        let k0 = [ element ] in
        return @@ List.map (fun x -> Push x) @@ k0 @ k3'' @ k2'' @ k1''
      | Binary_operator_resolution_1_of_4(x1,op) ->
        let%orzero Binary_operation = element in
        return [ Pop_dynamic_targeted(
            Binary_operator_resolution_2_of_4(x1,op)) ]
      | Binary_operator_resolution_2_of_4(x1,op) ->
        begin
          match op,element with
          | Binary_operator_plus,Continuation_value(Abs_filtered_value(Abs_value_int as abstract_value,patsp,patsn))
          | Binary_operator_int_minus,Continuation_value(Abs_filtered_value(Abs_value_int as abstract_value,patsp,patsn))
          | Binary_operator_int_less_than,Continuation_value(Abs_filtered_value(Abs_value_int as abstract_value,patsp,patsn))
          | Binary_operator_int_less_than_or_equal_to,Continuation_value(Abs_filtered_value(Abs_value_int as abstract_value,patsp,patsn))
          | Binary_operator_equal_to,Continuation_value(Abs_filtered_value(Abs_value_int as abstract_value,patsp,patsn))
          | Binary_operator_equal_to,Continuation_value(Abs_filtered_value((Abs_value_bool _) as abstract_value,patsp,patsn))
          | Binary_operator_bool_and,Continuation_value(Abs_filtered_value((Abs_value_bool _) as abstract_value,patsp,patsn))
          | Binary_operator_bool_or,Continuation_value(Abs_filtered_value((Abs_value_bool _) as abstract_value,patsp,patsn))
          | Binary_operator_plus,Continuation_value(Abs_filtered_value(Abs_value_string as abstract_value,patsp,patsn))
          | Binary_operator_equal_to,Continuation_value(Abs_filtered_value(Abs_value_string as abstract_value,patsp,patsn)) ->
            [%guard (Pattern_set.is_empty patsp) ];
            [%guard (Pattern_set.is_empty patsn) ];
            return [ Pop_dynamic_targeted(
                Binary_operator_resolution_3_of_4(x1,op,abstract_value)) ]
          | _ -> zero ()
        end
      | Binary_operator_resolution_3_of_4(x1,op,abstract_value) ->
        begin
          match op,abstract_value with
          | Binary_operator_plus,Abs_value_int
          | Binary_operator_int_minus,Abs_value_int ->
            let%orzero
              Continuation_value(Abs_filtered_value(Abs_value_int,patsp,patsn)) =
              element
            in
            [%guard (Pattern_set.is_empty patsp) ];
            [%guard (Pattern_set.is_empty patsn) ];
            return [ Pop_dynamic_targeted(
                Binary_operator_resolution_4_of_4(x1,op,Abs_value_int)) ]
          | Binary_operator_int_less_than,Abs_value_int
          | Binary_operator_int_less_than_or_equal_to,Abs_value_int
          | Binary_operator_equal_to,Abs_value_int ->
            let%orzero
              Continuation_value(Abs_filtered_value(Abs_value_int,patsp,patsn)) =
              element
            in
            [%guard (Pattern_set.is_empty patsp) ];
            [%guard (Pattern_set.is_empty patsn) ];
            let%bind v = pick_enum @@ List.enum [Abs_value_bool(true); Abs_value_bool(false)] in
            return [ Pop_dynamic_targeted(
                Binary_operator_resolution_4_of_4(x1,op,v)) ]
          | Binary_operator_equal_to,Abs_value_bool op1bool ->
            let%orzero
              Continuation_value(Abs_filtered_value(Abs_value_bool op2bool,patsp,patsn)) =
              element
            in
            [%guard (Pattern_set.is_empty patsp) ];
            [%guard (Pattern_set.is_empty patsn) ];
            return [ Pop_dynamic_targeted(
                Binary_operator_resolution_4_of_4(x1,op,Abs_value_bool(op1bool = op2bool))) ]
          | Binary_operator_bool_and,Abs_value_bool op1bool ->
            let%orzero
              Continuation_value(Abs_filtered_value(Abs_value_bool op2bool,patsp,patsn)) =
              element
            in
            [%guard (Pattern_set.is_empty patsp) ];
            [%guard (Pattern_set.is_empty patsn) ];
            return [ Pop_dynamic_targeted(
                Binary_operator_resolution_4_of_4(x1,op,Abs_value_bool(op1bool && op2bool))) ]
          | Binary_operator_bool_or,Abs_value_bool op1bool ->
            let%orzero
              Continuation_value(Abs_filtered_value(Abs_value_bool op2bool,patsp,patsn)) =
              element
            in
            [%guard (Pattern_set.is_empty patsp) ];
            [%guard (Pattern_set.is_empty patsn) ];
            return [ Pop_dynamic_targeted(
                Binary_operator_resolution_4_of_4(x1,op,Abs_value_bool(op1bool || op2bool))) ]
          | Binary_operator_plus,Abs_value_string ->
            let%orzero
              Continuation_value(Abs_filtered_value(Abs_value_string,patsp,patsn)) =
              element
            in
            [%guard (Pattern_set.is_empty patsp) ];
            [%guard (Pattern_set.is_empty patsn) ];
            return [ Pop_dynamic_targeted(
                Binary_operator_resolution_4_of_4(x1,op,Abs_value_string)) ]
          | Binary_operator_equal_to,Abs_value_string ->
            let%orzero
              Continuation_value(Abs_filtered_value(Abs_value_string,patsp,patsn)) =
              element
            in
            [%guard (Pattern_set.is_empty patsp) ];
            [%guard (Pattern_set.is_empty patsn) ];
            let%bind v = pick_enum @@ List.enum [Abs_value_bool(true); Abs_value_bool(false)] in
            return [ Pop_dynamic_targeted(
                Binary_operator_resolution_4_of_4(x1,op,v)) ]
          | _ -> raise @@ Utils.Invariant_failure "Accumulated wrong binary operand."
        end
      | Binary_operator_resolution_4_of_4(x1,op,abstract_value) ->
        let%orzero Lookup_var(x1',patsp,patsn) = element in
        [%guard (equal_var x1 x1') ];
        begin
          match op,abstract_value with
          | Binary_operator_plus,Abs_value_int
          | Binary_operator_int_minus,Abs_value_int ->
            [%guard (Pattern_set.subset
                       patsp (Pattern_set.singleton Int_pattern)) ];
            [%guard (not @@ Pattern_set.mem Int_pattern patsn) ];
            return [ Push (Continuation_value(Abs_filtered_value(
                abstract_value,Pattern_set.empty,Pattern_set.empty))) ]
          | Binary_operator_int_less_than,Abs_value_bool result_bool
          | Binary_operator_int_less_than_or_equal_to,Abs_value_bool result_bool
          | Binary_operator_equal_to,Abs_value_bool result_bool
          | Binary_operator_bool_and,Abs_value_bool result_bool
          | Binary_operator_bool_or,Abs_value_bool result_bool ->
            [% guard (Pattern_set.subset
                        patsp (Pattern_set.singleton (Bool_pattern(result_bool)))) ];
            [% guard (not @@ Pattern_set.mem (Bool_pattern(result_bool)) patsn) ];
            return [ Push (Continuation_value(Abs_filtered_value(
                abstract_value,Pattern_set.empty,Pattern_set.empty))) ]
          | Binary_operator_plus,Abs_value_string ->
            [%guard (Pattern_set.subset
                       patsp (Pattern_set.singleton String_pattern)) ];
            [%guard (not @@ Pattern_set.mem String_pattern patsn) ];
            return [ Push (Continuation_value(Abs_filtered_value(
                abstract_value,Pattern_set.empty,Pattern_set.empty))) ]
          | _ -> raise @@ Utils.Invariant_failure "Invalid result of binary operation."
        end
      | Unary_operator_resolution_1_of_3(x1,op) ->
        let%orzero Unary_operation = element in
        return [ Pop_dynamic_targeted(
            Unary_operator_resolution_2_of_3(x1,op)) ]
      | Unary_operator_resolution_2_of_3(x1,op) ->
        begin
          match op,element with
          | Unary_operator_bool_not,Continuation_value(Abs_filtered_value(Abs_value_bool opbool,patsp,patsn)) ->
            [%guard (Pattern_set.is_empty patsp) ];
            [%guard (Pattern_set.is_empty patsn) ];
            return [ Pop_dynamic_targeted(
                Unary_operator_resolution_3_of_3(x1,op,Abs_value_bool (not opbool))) ]
          | _ -> zero ()
        end
      | Unary_operator_resolution_3_of_3(x1,op,abstract_value) ->
        let%orzero Lookup_var(x1',patsp,patsn) = element in
        [%guard (equal_var x1 x1') ];
        begin
          match op,abstract_value with
          | Unary_operator_bool_not, Abs_value_bool result_bool ->
            [% guard (Pattern_set.subset
                        patsp (Pattern_set.singleton (Bool_pattern(result_bool)))) ];
            [% guard (not @@ Pattern_set.mem (Bool_pattern(result_bool)) patsn) ];
            return [ Push (Continuation_value(Abs_filtered_value(
                abstract_value,Pattern_set.empty,Pattern_set.empty))) ]
          | _ -> raise @@ Utils.Invariant_failure "Invalid result of unary operation."
        end
      | Indexing_resolution_1_of_4(x1) ->
        let%orzero Indexing = element in
        return [ Pop_dynamic_targeted(
            Indexing_resolution_2_of_4(x1)) ]
      | Indexing_resolution_2_of_4(x1) ->
        let%orzero
          Continuation_value(Abs_filtered_value(Abs_value_int,patsp,patsn)) =
          element
        in
        [%guard (Pattern_set.is_empty patsp) ];
        [%guard (Pattern_set.is_empty patsn) ];
        return [ Pop_dynamic_targeted(
            Indexing_resolution_3_of_4(x1)) ]
      | Indexing_resolution_3_of_4(x1) ->
        let%orzero
          Continuation_value(Abs_filtered_value(Abs_value_string,patsp,patsn)) =
          element
        in
        [%guard (Pattern_set.is_empty patsp) ];
        [%guard (Pattern_set.is_empty patsn) ];
        return [ Pop_dynamic_targeted(
            Indexing_resolution_4_of_4(x1,Abs_value_string)) ]
      | Indexing_resolution_4_of_4(x1,abstract_value) ->
        let%orzero Lookup_var(x1',patsp,patsn) = element in
        [%guard (equal_var x1 x1') ];
        begin
          match abstract_value with
          | Abs_value_string ->
            [%guard (Pattern_set.subset
                       patsp (Pattern_set.singleton String_pattern)) ];
            [%guard (not @@ Pattern_set.mem String_pattern patsn) ];
            return [ Push (Continuation_value(Abs_filtered_value(
                abstract_value,Pattern_set.empty,Pattern_set.empty))) ]
          | _ -> raise @@ Utils.Invariant_failure "Invalid result of indexing."
        end
    ;;

    let perform_untargeted_dynamic_pop element action =
      Nondeterminism_monad.enum @@
      let open Nondeterminism_monad in
      match action with
      | Do_jump ->
        let%orzero (Jump(acl1,ctx)) = element in
        return ([], Program_point_state(acl1,ctx))
      | Value_discovery_1_of_2 ->
        let%orzero (Continuation_value abs_filtered_value) = element in
        return ( [ Pop_dynamic_targeted(Value_discovery_2_of_2) ]
               , Result_state abs_filtered_value
               )
    ;;
  end;;

  module Ddpa_pds_reachability =
    Pds_reachability.Make(Ddpa_pds_reachability_basis)(Dph)
  ;;

  type ddpa_analysis_logging_data =
    { ddpa_logging_prefix : string
    ; ddpa_closure_steps : int
    }

  type ddpa_analysis =
    { ddpa_graph : ddpa_graph
    ; ddpa_graph_fully_closed : bool
    ; pds_reachability : Ddpa_pds_reachability.analysis
    ; ddpa_active_nodes : Annotated_clause_set.t
    (** The active nodes in the DDPA graph.  This set is maintained
        incrementally as edges are added. *)
    ; ddpa_active_non_immediate_nodes : Annotated_clause_set.t
    (** A subset of [ddpa_active_nodes] which only contains the
        non-immediate nodes.  This is useful during closure. *)
    ; ddpa_logging_data : ddpa_analysis_logging_data option
    (** Data associated with logging, if appropriate. *)
    }
  ;;

  let pp_ddpa analysis =
    Printf.sprintf
      "{\n  ddpa_graph = %s;\n  ddpa_graph_fully_closed = %s;\n  pds_reachability = %s;\n  ddpa_active_nodes = %s;\n  ddpa_active_non_immediate_nodes = %s;\n}"
      (pp_ddpa_graph analysis.ddpa_graph)
      (string_of_bool analysis.ddpa_graph_fully_closed)
      (Ddpa_pds_reachability.pp_analysis analysis.pds_reachability)
      (pp_annotated_clause_set analysis.ddpa_active_nodes)
      (pp_annotated_clause_set analysis.ddpa_active_non_immediate_nodes)
  ;;

  let get_size analysis =
    let pds_node_count, pds_edge_count = Ddpa_pds_reachability.get_size analysis.pds_reachability in
    let filter_inferrable_nodes nodes =
      nodes
      |> Annotated_clause_set.filter (
        fun node ->
          match node with
          | Enter_clause _
          | Exit_clause _ -> false
          | _ -> true
      )
    in
    let module Context_set = Set.Make(struct
        type t = C.t
        let compare = C.compare
      end)
    in
    let contexts =
      Ddpa_pds_reachability.get_current_states analysis.pds_reachability
      |> Enum.filter_map
        (function
          | Program_point_state(_,ctx) -> Some ctx
          | Result_state _ -> None
        )
      |> Context_set.of_enum
    in
    lazy_logger `info
      (fun () ->
         "Contexts used: " ^
         (String_utils.concat_sep_delim "{" "}" "," @@
          Enum.map C.ppa @@ Context_set.enum contexts)
      );
    Annotated_clause_set.cardinal (filter_inferrable_nodes analysis.ddpa_active_nodes),
    Annotated_clause_set.cardinal (filter_inferrable_nodes analysis.ddpa_active_non_immediate_nodes),
    analysis.ddpa_graph
    |> edges_of
    |> List.of_enum
    |> List.length,
    pds_node_count,
    pds_edge_count,
    Context_set.cardinal contexts
  ;;

  let empty_analysis logging_prefix_opt =
    (* The initial reachability analysis should include an edge function which
       always allows discarding the bottom-of-stack marker. *)
    let empty_reachability =
      Ddpa_pds_reachability.empty ~logging_prefix:logging_prefix_opt ()
    in
    let initial_reachability =
      empty_reachability
      |> Ddpa_pds_reachability.add_edge_function
        (fun state -> Enum.singleton ([Pop Bottom_of_stack], state))
    in
    { ddpa_graph = Ddpa_graph.empty
    ; ddpa_graph_fully_closed = true
    ; pds_reachability = initial_reachability
    ; ddpa_active_nodes = Annotated_clause_set.singleton Start_clause
    ; ddpa_active_non_immediate_nodes = Annotated_clause_set.empty
    ; ddpa_logging_data = None
    }
  ;;

  let log_ddpa_graph level analysis name_fn =
    match analysis.ddpa_logging_data with
    | None -> ()
    | Some data ->
      let name = name_fn data in
      Ddpa_graph_logger.log level name analysis.ddpa_graph
  ;;

  let add_edges edges analysis =
    let already_present =
      Enum.clone edges
      |> Enum.for_all
        (fun edge -> Ddpa_graph.has_edge edge analysis.ddpa_graph)
    in
    if already_present then (analysis,false) else
      (* ***
         First, update the PDS reachability analysis with the new edge
         information.
      *)
      let add_edge_for_reachability edge reachability =
        (* Unpack the edge *)
        let (Ddpa_edge(acl1,acl0)) = edge in
        (* Create an edge function to generate targeted dynamic pops for each
           edge. *)
        let edge_function state =
          Logger_utils.lazy_bracket_log (lazy_logger `trace)
            (fun () -> Printf.sprintf "DDPA %s edge function at state %s"
                (pp_ddpa_edge edge) (pp_pds_state state))
            (fun edges ->
               let pp_output (actions,target) =
                 String_utils.pp_tuple
                   (String_utils.pp_list Ddpa_pds_reachability.pp_stack_action)
                   pp_pds_state
                   (actions,target)
               in
               Printf.sprintf "Generates edges: %s"
                 (String_utils.pp_list pp_output @@
                  List.of_enum @@ Enum.clone edges)) @@
          fun () ->
          let zero = Enum.empty in
          let%orzero Program_point_state(acl0',ctx) = state in
          (* TODO: There should be a way to associate each edge function with
                   its corresponding acl0 rather than using this guard. *)
          [%guard (compare_annotated_clause acl0 acl0' == 0) ];
          let open Nondeterminism_monad in
          (* TODO: It'd be nice if we had a terser way to represent stack
                   processing operations (those that simply reorder the stack
                   without transitioning to a different node). *)
          let targeted_dynamic_pops = Enum.concat @@ Enum.map enum @@ List.enum
              [
                (* 1b. Value drop *)
                begin
                  return (Value_drop, Program_point_state(acl0,ctx))
                end
                ;
                (* 2a. Transitivity *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x, Abs_var_body x'))) = acl1
                  in
                  (* x = x' *)
                  return (Variable_aliasing(x,x'),Program_point_state(acl1,ctx))
                end
                ;
                (* 2b. Stateless non-matching clause skip *)
                begin
                  let%orzero (Unannotated_clause(Abs_clause(x,_))) = acl1 in
                  (* x' = b *)
                  return ( Stateless_nonmatching_clause_skip_1_of_2 x
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 3b. Value capture *)
                begin
                  return ( Value_capture_1_of_3
                         , Program_point_state(acl0, ctx)
                         )
                end
                ;
                (* 4a. Function parameter wiring *)
                begin
                  let%orzero (Enter_clause(x,x',c)) = acl1 in
                  let%orzero (Abs_clause(_,Abs_appl_body (_,x3''))) = c in
                  begin
                    if not (equal_var x' x3'') then
                      raise @@ Utils.Invariant_failure "Ill-formed wiring node."
                    else
                      ()
                  end;
                  (* x =(down)c x' *)
                  [%guard C.is_top c ctx];
                  let%bind ctx' = pick_enum @@ C.pop ctx in
                  return (Variable_aliasing(x,x'),Program_point_state(acl1,ctx'))
                end
                ;
                (* 4b. Function return wiring start *)
                begin
                  let%orzero (Exit_clause(x,_,c)) = acl1 in
                  let%orzero (Abs_clause(x1'',Abs_appl_body(x2'',x3''))) = c in
                  begin
                    if not (equal_var x x1'') then
                      raise @@ Utils.Invariant_failure "Ill-formed wiring node."
                    else
                      ()
                  end;
                  (* x =(up)c _ (for functions) *)
                  return ( Function_call_flow_validation(x2'',x3'',acl0,ctx,Unannotated_clause(c),ctx,x)
                         , Program_point_state(Unannotated_clause(c),ctx)
                         )
                end
                ;
                (* 4c. Function return wiring finish *)
                begin
                  let%orzero (Exit_clause(x,x',c)) = acl1 in
                  let%orzero (Abs_clause(x1'',Abs_appl_body _)) = c in
                  begin
                    if not (equal_var x x1'') then
                      raise @@ Utils.Invariant_failure "Ill-formed wiring node."
                    else
                      ()
                  end;
                  (* x =(up)c x' *)
                  let%bind ctx' = pick_enum @@ C.push c ctx in
                  return ( Function_call_flow_validation_resolution_1_of_2(x,x')
                         , Program_point_state(acl1,ctx')
                         )
                end
                ;
                (* 4d. Function non-local wiring *)
                begin
                  let%orzero (Enter_clause(x'',x',c)) = acl1 in
                  let%orzero (Abs_clause(_,Abs_appl_body(x2'',x3''))) = c in
                  begin
                    if not (equal_var x' x3'') then
                      raise @@ Utils.Invariant_failure "Ill-formed wiring node."
                    else
                      ()
                  end;
                  (* x'' =(down)c x' *)
                  [%guard C.is_top c ctx];
                  let%bind ctx' = pick_enum @@ C.pop ctx in
                  return ( Function_closure_lookup(x'',x2'')
                         , Program_point_state(acl1,ctx')
                         )
                end
                ;
                (* 5a, 5b, and 5e. Conditional entrance wiring *)
                begin
                  (* This block represents *all* conditional closure handling on
                     the entering side. *)
                  let%orzero (Enter_clause(x',x1,c)) = acl1 in
                  let%orzero
                    (Abs_clause(_,Abs_conditional_body(x1',p,f1,_))) = c
                  in
                  begin
                    if not (equal_var x1 x1') then
                      raise @@ Utils.Invariant_failure "Ill-formed wiring node."
                    else
                      ()
                  end;
                  let Abs_function_value(f1x,_) = f1 in
                  (* x'' =(down)c x' for conditionals *)
                  let closure_for_positive_path = equal_var f1x x' in
                  return ( Conditional_closure_lookup
                             (x',x1,p,closure_for_positive_path)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 5c, 5d. Conditional return wiring *)
                begin
                  let%orzero (Exit_clause(x,x',c)) = acl1 in
                  let%orzero
                    (Abs_clause(x2,Abs_conditional_body(x1,pat,f1,_))) = c
                  in
                  begin
                    if not (equal_var x x2) then
                      raise @@ Utils.Invariant_failure "Ill-formed wiring node."
                    else
                      ()
                  end;
                  (* x =(up) x' for conditionals *)
                  let Abs_function_value(_,Abs_expr(cls)) = f1 in
                  let f1ret = rv cls in
                  let then_branch = equal_var f1ret x' in
                  return ( Conditional_subject_validation(
                      x,x',x1,pat,then_branch,acl1,ctx)
                         , Program_point_state(Unannotated_clause(c),ctx)
                    )
                end
                ;
                (* 6a. Record destruction *)
                begin
                  let%orzero
                    (Unannotated_clause(
                        Abs_clause(x,Abs_projection_body(x',l)))) = acl1
                  in
                  (* x = x'.l *)
                  return ( Record_projection_lookup(x,x',l)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 6b. Record projection *)
                begin
                  return ( Record_projection_1_of_2
                         , Program_point_state(acl0,ctx)
                         )
                end
                ;
                (* 7a. Function filter validation *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(
                         x,Abs_value_body(Abs_value_function(v))))) = acl1
                  in
                  (* x = f *)
                  return ( Function_filter_validation(x,v)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 7b. Record validation *)
                begin
                  let%orzero
                    (Unannotated_clause(
                        Abs_clause(x,Abs_value_body(Abs_value_record(r))))) = acl1
                  in
                  (* x = r *)
                  let target_state = Program_point_state(acl1,ctx) in
                  return ( Record_filter_validation(
                      x,r,acl1,ctx)
                         , target_state
                    )
                end
                ;
                (* 7c. Integer filter validation *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(
                         x,Abs_value_body(Abs_value_int)))) = acl1
                  in
                  (* x = int *)
                  return ( Int_filter_validation(x)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 7d, 7e. Boolean filter validation *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(
                         x,Abs_value_body(Abs_value_bool(b))))) = acl1
                  in
                  (* x = true OR x = false *)
                  return ( Bool_filter_validation(x,b)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 7f. String filter validation *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(
                         x,Abs_value_body(Abs_value_string)))) = acl1
                  in
                  (* x = <string> *)
                  return ( String_filter_validation(x)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 8a. Assignment result *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x, Abs_update_body _))) = acl1
                  in
                  (* x = x' <- x'' -- produce {} for x *)
                  return ( Empty_record_value_discovery x
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 8b. Dereference lookup *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x, Abs_deref_body(x')))) = acl1
                  in
                  (* x = !x' *)
                  return ( Dereference_lookup(x,x')
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 8c. Cell validation *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(
                         x,Abs_value_body(Abs_value_ref(cell))))) = acl1
                  in
                  (* x = ref x' *)
                  return ( Cell_filter_validation(x,cell)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 8d. Cell dereference *)
                begin
                  return ( Cell_dereference_1_of_2
                         , Program_point_state(acl0, ctx) )
                end
                ;
                (* 9a. Cell update alias analysis initialization *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(
                         _, Abs_update_body(x',_)))) = acl1
                  in
                  (* x''' = x' <- x'' *)
                  let source_state = Program_point_state(acl1,ctx) in
                  let target_state = Program_point_state(acl0,ctx) in
                  return ( Cell_update_alias_analysis_init_1_of_2(
                      x',source_state,target_state)
                         , Program_point_state(acl0, ctx) )
                end
                ; (* 9b,9c. Alias resolution *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(
                         _, Abs_update_body(_,x'')))) = acl1
                  in
                  (* x''' = x' <- x'' *)
                  return ( Alias_analysis_resolution_1_of_5(x'')
                         , Program_point_state(acl1, ctx) )
                end
                ; (* 10a. Stateful non-side-effecting clause skip *)
                begin
                  let%orzero (Unannotated_clause(Abs_clause(x,b))) = acl1 in
                  [% guard (is_immediate acl1) ];
                  [% guard (b |>
                            (function
                              | Abs_update_body _ -> false
                              | _ -> true)) ];
                  (* x' = b *)
                  return ( Nonsideeffecting_nonmatching_clause_skip x
                         , Program_point_state(acl1,ctx)
                         )
                end
                ; (* 10b. Side-effect search initialization *)
                begin
                  let%orzero (Exit_clause(x'',_,c)) = acl1 in
                  (* x'' =(up)c x' *)
                  let%bind ctx' =
                    match c with
                    | Abs_clause(_,Abs_appl_body _) -> pick_enum @@ C.push c ctx
                    | Abs_clause(_,Abs_conditional_body _) -> return ctx
                    | _ -> zero ()
                  in
                  return ( Side_effect_search_init_1_of_2(x'',acl0,ctx)
                         , Program_point_state(acl1,ctx') )
                end
                ; (* 10c. Side-effect search non-matching clause skip *)
                begin
                  let%orzero (Unannotated_clause(Abs_clause(_,b))) = acl1 in
                  [% guard (is_immediate acl1) ];
                  [% guard (b |>
                            (function
                              | Abs_update_body _ -> false
                              | _ -> true)) ];
                  (* x' = b *)
                  return ( Side_effect_search_nonmatching_clause_skip
                         , Program_point_state(acl1,ctx) )
                end
                ; (* 10d. Side-effect search exit wiring node *)
                begin
                  let%orzero (Exit_clause(_,_,c)) = acl1 in
                  (* x'' =(up)c x' *)
                  let%bind ctx' =
                    match c with
                    | Abs_clause(_,Abs_appl_body _) -> pick_enum @@ C.push c ctx
                    | Abs_clause(_,Abs_conditional_body _) -> return ctx
                    | _ -> zero ()
                  in
                  return ( Side_effect_search_exit_wiring
                         , Program_point_state(acl1,ctx') )
                end
                ; (* 10e. Side-effect search enter wiring node *)
                begin
                  let%orzero (Enter_clause(_,_,c)) = acl1 in
                  (* x'' =(down)c x' *)
                  let%bind ctx' =
                    match c with
                    | Abs_clause(_,Abs_appl_body _) -> pick_enum @@ C.pop ctx
                    | Abs_clause(_,Abs_conditional_body _) -> return ctx
                    | _ -> zero ()
                  in
                  return ( Side_effect_search_enter_wiring
                         , Program_point_state(acl1,ctx') )
                end
                (* FIXME: why does this clause kill performance? *)
                ; (* 10f. Side-effect search without discovery *)
                begin
                  return ( Side_effect_search_without_discovery
                         , Program_point_state(acl0,ctx) )
                end
                ; (* 10g. Side-effect search alias analysis initialization *)
                begin
                  let%orzero (Unannotated_clause(
                      Abs_clause(_,Abs_update_body(x',_)))) = acl1
                  in
                  return ( Side_effect_search_alias_analysis_init(x',acl0,ctx)
                         , Program_point_state(acl1,ctx) )
                end
                ; (* 10h,10i. Side-effect search alias analysis resolution *)
                begin
                  let%orzero (Unannotated_clause(
                      Abs_clause(_,Abs_update_body(_,x'')))) = acl1
                  in
                  return ( Side_effect_search_alias_analysis_resolution_1_of_4(
                      x'')
                         , Program_point_state(acl1,ctx) )
                end
                ; (* 10j. Side-effect search escape *)
                begin
                  return ( Side_effect_search_escape_1_of_2
                         , Program_point_state(acl0,ctx) )
                end
                ; (* 10k. Side-effect search escape completion *)
                begin
                  return ( Side_effect_search_escape_completion_1_of_4
                         , Program_point_state(acl0,ctx) )
                end
                ; (* 11a. Binary operation operand lookup *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x1,
                                                   Abs_binary_operation_body(x2,_,x3)))) = acl1
                  in
                  (* x1 = x2 op x3 *)
                  return ( Binary_operator_lookup_init(
                      x1,x2,x3,acl1,ctx,acl0,ctx)
                         , Program_point_state(acl1,ctx)
                    )
                end
                ; (* 11b. Unary operation operand lookup *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x1,
                                                   Abs_unary_operation_body(_,x2)))) = acl1
                  in
                  (* x1 = op x2 *)
                  return ( Unary_operator_lookup_init(
                      x1,x2,acl0,ctx)
                         , Program_point_state(acl1,ctx)
                    )
                end
                ; (* 11c. Indexing lookup *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x1,
                                                   Abs_indexing_body(x2,x3)))) = acl1
                  in
                  (* x1 = x2[x3] *)
                  return ( Indexing_lookup_init(
                      x1,x2,x3,acl1,ctx,acl0,ctx)
                         , Program_point_state(acl1,ctx)
                    )
                end
                ; (* 12a,12b,12c,13a,13b,13c,13d,13e,13f,13g,13h,13i,13j,13k,13l,14a,14b,14c. Binary operator resolution *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x1,
                                                   Abs_binary_operation_body(_,op,_)))) = acl1
                  in
                  (* x1 = x2 op x3 *)
                  return ( Binary_operator_resolution_1_of_4(x1,op)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ; (* 13m,13n. Unary operator resolution *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x1,
                                                   Abs_unary_operation_body(op,_)))) = acl1
                  in
                  (* x1 = op x2 *)
                  return ( Unary_operator_resolution_1_of_3(x1,op)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ; (* 14d. Indexing resolution *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x1,
                                                   Abs_indexing_body(_,_)))) = acl1
                  in
                  (* x1 = x2[x3] *)
                  return ( Indexing_resolution_1_of_4(x1)
                         , Program_point_state(acl1,ctx)
                         )
                end
              ]
          in
          targeted_dynamic_pops
          |> Enum.map
            (fun (action,state) -> ([Pop_dynamic_targeted(action)], state))
        in
        (* Create another function to handle the untargeted dynamic pops. *)
        let untargeted_dynamic_pop_action_function state =
          let zero = Enum.empty in
          let%orzero Program_point_state(acl0',_) = state in
          (* TODO: There should be a way to associate each action function with
                   its corresponding acl0 rather than using this guard. *)
          [%guard (compare_annotated_clause acl0 acl0' == 0)];
          let open Option.Monad in
          let untargeted_dynamic_pops = Enum.filter_map identity @@ List.enum
              [
                (* 1a. Value discovery. *)
                begin
                  return @@ Value_discovery_1_of_2
                end
                ;
                (* 3a. Jump. *)
                begin
                  return @@ Do_jump
                end
              ]
          in
          untargeted_dynamic_pops
        in
        (* Put it all together with the reachability parameter to produce the
           new reachability structure. *)
        reachability
        |> Ddpa_pds_reachability.add_edge_function edge_function
        |> Ddpa_pds_reachability.add_untargeted_dynamic_pop_action_function
          untargeted_dynamic_pop_action_function
      in
      let pds_reachability' =
        Enum.clone edges
        |> Enum.fold (flip add_edge_for_reachability) analysis.pds_reachability
      in
      (* ***
         Next, add the edge to the DDPA graph.
      *)
      let ddpa_graph' =
        Enum.clone edges
        |> Enum.fold (flip Ddpa_graph.add_edge) analysis.ddpa_graph
      in
      (* ***
         Now, perform closure over the active node set.  This function uses a
         list of enumerations of nodes to explore.  This reduces the cost of
         managing the work queue.
      *)
      let rec find_new_active_nodes from_acls_enums results_so_far =
        match from_acls_enums with
        | [] -> results_so_far
        | from_acls_enum::from_acls_enums' ->
          if Enum.is_empty from_acls_enum
          then find_new_active_nodes from_acls_enums' results_so_far
          else
            let from_acl = Enum.get_exn from_acls_enum in
            if Annotated_clause_set.mem from_acl analysis.ddpa_active_nodes ||
               Annotated_clause_set.mem from_acl results_so_far
            then find_new_active_nodes from_acls_enums results_so_far
            else
              let results_so_far' =
                Annotated_clause_set.add from_acl results_so_far
              in
              let from_here = ddpa_graph' |> Ddpa_graph.succs from_acl in
              find_new_active_nodes (from_here::from_acls_enums) results_so_far'
      in
      let (ddpa_active_nodes',ddpa_active_non_immediate_nodes') =
        let new_active_root_nodes =
          Enum.clone edges
          |> Enum.filter_map
            (fun (Ddpa_edge(acl_left,acl_right)) ->
               if Annotated_clause_set.mem acl_left analysis.ddpa_active_nodes
               then Some acl_right
               else None)
          |> Enum.filter
            (fun acl ->
               not @@ Annotated_clause_set.mem acl analysis.ddpa_active_nodes)
        in
        let new_active_nodes =
          find_new_active_nodes [new_active_root_nodes]
            Annotated_clause_set.empty
        in
        ( Annotated_clause_set.union analysis.ddpa_active_nodes
            new_active_nodes
        , Annotated_clause_set.union analysis.ddpa_active_non_immediate_nodes
            ( new_active_nodes |> Annotated_clause_set.filter
                (not % is_annotated_clause_immediate) )
        )
      in
      (
        { ddpa_graph = ddpa_graph'
        ; ddpa_graph_fully_closed = false
        ; pds_reachability =  pds_reachability'
        ; ddpa_active_nodes = ddpa_active_nodes'
        ; ddpa_active_non_immediate_nodes = ddpa_active_non_immediate_nodes'
        ; ddpa_logging_data = analysis.ddpa_logging_data
        }
      , true
      )
  ;;

  let create_initial_analysis ?logging_prefix:(logging_prefix=None) e =
    let Abs_expr(cls) = lift_expr e in
    (* Put the annotated clauses together. *)
    let acls =
      List.enum cls
      |> Enum.map (fun x -> Unannotated_clause x)
      |> Enum.append (Enum.singleton Start_clause)
      |> flip Enum.append (Enum.singleton End_clause)
    in
    (* For each pair, produce a DDPA edge. *)
    let rec mk_edges acls' =
      match Enum.get acls' with
      | None -> []
      | Some acl1 ->
        match Enum.peek acls' with
        | None -> []
        | Some acl2 ->
          Ddpa_edge(acl1,acl2) :: mk_edges acls'
    in
    let edges = List.enum @@ mk_edges acls in
    let empty_analysis' =
      match logging_prefix with
      | None -> empty_analysis None
      | Some prefix ->
        { (empty_analysis @@ Some prefix) with
          ddpa_logging_data = Some
              { ddpa_closure_steps = 0
              ; ddpa_logging_prefix = prefix
              }
        }
    in
    let analysis = fst @@ add_edges edges empty_analysis' in
    logger `trace "Created initial analysis";
    log_ddpa_graph Ddpa_graph_logger.Ddpa_log_all analysis
      (fun data ->
         Ddpa_graph_logger.Ddpa_graph_name_initial data.ddpa_logging_prefix);
    analysis
  ;;

  let restricted_values_of_variable x acl ctx patsp patsn analysis =
    Logger_utils.lazy_bracket_log (lazy_logger `trace)
      (fun () ->
         Printf.sprintf "Determining values of variable %s at position %s%s"
           (pp_var x) (pp_annotated_clause acl) @@
         if Pattern_set.is_empty patsp && Pattern_set.is_empty patsn
         then ""
         else
           Printf.sprintf " with pattern sets %s and %s"
             (pp_pattern_set patsp) (pp_pattern_set patsn)
      )
      (fun (values, _) ->
         String_utils.concat_sep_delim "{" "}" ", " @@
         Enum.map pp_abs_filtered_value @@ Enum.clone values)
    @@ fun () ->
    let start_state = Program_point_state(acl,ctx) in
    let start_actions =
      [Push Bottom_of_stack; Push (Lookup_var(x,patsp,patsn))]
    in
    let reachability = analysis.pds_reachability in
    let reachability' =
      reachability
      |> Ddpa_pds_reachability.add_start_state start_state start_actions
    in
    let analysis' = { analysis with pds_reachability = reachability' } in
    let values =
      reachability'
      |> Ddpa_pds_reachability.get_reachable_states start_state start_actions
      |> Enum.filter_map
        (function
          | Program_point_state _ -> None
          | Result_state v -> Some v)
    in
    (values, analysis')
  ;;

  let values_of_variable x acl analysis =
    let (values, analysis') =
      restricted_values_of_variable x acl C.empty
        Pattern_set.empty Pattern_set.empty analysis
    in
    (Abs_filtered_value_set.of_enum values, analysis')
  ;;

  let contextual_values_of_variable x acl ctx analysis =
    let (values, analysis') =
      restricted_values_of_variable x acl ctx
        Pattern_set.empty Pattern_set.empty analysis
    in
    (Abs_filtered_value_set.of_enum values, analysis')
  ;;

  let wire site_cl func x1 x2 graph =
    let site_acl = Unannotated_clause(site_cl) in
    let Abs_function_value(x0, Abs_expr(body)) = func in
    let wire_in_acl = Enter_clause(x0,x1,site_cl) in
    let wire_out_acl = Exit_clause(x2,rv body,site_cl) in
    let pred_edges =
      Ddpa_graph.preds site_acl graph
      |> Enum.map (fun acl' -> Ddpa_edge(acl',wire_in_acl))
    in
    let succ_edges =
      Ddpa_graph.succs site_acl graph
      |> Enum.map (fun acl' -> Ddpa_edge(wire_out_acl,acl'))
    in
    let inner_edges =
      List.enum body
      |> Enum.map (fun cl -> Unannotated_clause(cl))
      |> Enum.append (Enum.singleton wire_in_acl)
      |> flip Enum.append (Enum.singleton wire_out_acl)
      |> Utils.pairwise_enum_fold
        (fun acl1 acl2 -> Ddpa_edge(acl1,acl2))
    in
    Enum.append pred_edges @@ Enum.append inner_edges succ_edges
  ;;

  let perform_closure_steps analysis =
    begin
      match analysis.ddpa_logging_data with
      | None -> lazy_logger `trace (fun () -> "Performing closure step")
      | Some data -> lazy_logger `trace (fun () ->
          (Printf.sprintf "Performing closure step %d"
             (data.ddpa_closure_steps+1)));
    end;
    (* We need to do work on each of the active, non-immediate nodes.  This
       process includes variable lookups, which may result in additional work
       being done; as a result, each closure step might change the underlying
       graph.  We'll keep the analysis in a ref so that, whenever work is done
       which produces a new analysis, we can just update the ref. *)
    let analysis_ref = ref analysis in
    let new_edges_enum = Nondeterminism_monad.enum
        (
          let open Nondeterminism_monad in
          let%bind acl =
            pick_enum @@
            Annotated_clause_set.enum analysis.ddpa_active_non_immediate_nodes
          in
          let has_values x patsp patsn =
            let (values,analysis') =
              restricted_values_of_variable
                x acl C.empty patsp patsn !analysis_ref
            in
            analysis_ref := analysis';
            not @@ Enum.is_empty values
          in
          match acl with
          | Unannotated_clause(Abs_clause(x1,Abs_appl_body(x2,x3)) as cl) ->
            lazy_logger `trace
              (fun () ->
                 Printf.sprintf "Considering application closure for clause %s"
                   (pp_abstract_clause cl));
            (* Make sure that a value shows up to the argument. *)
            [%guard has_values x3 Pattern_set.empty Pattern_set.empty];
            (* Get each of the function values. *)
            let (x2_values,analysis_2) =
              restricted_values_of_variable
                x2 acl C.empty Pattern_set.empty Pattern_set.empty !analysis_ref
            in
            analysis_ref := analysis_2;
            let%bind x2_value = pick_enum x2_values in
            let%orzero
              Abs_filtered_value(Abs_value_function(fn),_,_) = x2_value
            in
            (* Wire each one in. *)
            return @@ wire cl fn x3 x1 analysis_2.ddpa_graph
          | Unannotated_clause(
              Abs_clause(x1,Abs_conditional_body(x2,p,f1,f2)) as cl) ->
            lazy_logger `trace
              (fun () ->
                 Printf.sprintf "Considering conditional closure for clause %s"
                   (pp_abstract_clause cl));
            (* We have two functions we may wish to wire: f1 (if x2 has values
               which match the pattern) and f2 (if x2 has values which antimatch
               the pattern). *)
            [ (Pattern_set.singleton p, Pattern_set.empty, f1)
            ; (Pattern_set.empty, Pattern_set.singleton p, f2)
            ]
            |> List.enum
            |> Enum.filter_map
              (fun (patsp,patsn,f) ->
                 if has_values x2 patsp patsn then Some f else None)
            |> Enum.map (fun f -> wire cl f x2 x1 (!analysis_ref).ddpa_graph)
            |> Nondeterminism_monad.pick_enum
          | _ ->
            raise @@ Utils.Invariant_failure
              "Unhandled clause in perform_closure_steps"
        )
                         |> Enum.concat
    in
    (* Due to the stateful effects of computing the new edges, we're going to
       want to pull on the entire enumeration before we start looking at the
       analysis. *)
    let new_edges_list = List.of_enum new_edges_enum in
    (* Now we want to add all of the new edges.  If there are any new ones, we
       need to know about it. *)
    let (analysis',any_new) =
      add_edges (List.enum new_edges_list) !analysis_ref
    in
    let ddpa_logging_data' =
      match analysis'.ddpa_logging_data with
      | None -> None
      | Some data ->
        Some { data with ddpa_closure_steps = data.ddpa_closure_steps+1 }
    in
    let result =
      { analysis' with
        ddpa_graph_fully_closed = not any_new;
        ddpa_logging_data = ddpa_logging_data'
      }
    in
    begin
      match result.ddpa_logging_data with
      | None -> logger `trace "Completed closure step"
      | Some data -> lazy_logger `trace
                       (fun () -> Printf.sprintf "Completed closure step %d"
                           (data.ddpa_closure_steps));
    end;
    log_ddpa_graph Ddpa_graph_logger.Ddpa_log_all analysis
      (fun data -> Ddpa_graph_logger.Ddpa_graph_name_intermediate(
           data.ddpa_logging_prefix, data.ddpa_closure_steps));
    result
  ;;

  let is_fully_closed analysis = analysis.ddpa_graph_fully_closed;;

  let rec perform_full_closure analysis =
    if is_fully_closed analysis
    then
      begin
        logger `trace "Closure complete.";
        log_ddpa_graph Ddpa_graph_logger.Ddpa_log_result analysis
          (fun data ->
             Ddpa_graph_logger.Ddpa_graph_name_closed(data.ddpa_logging_prefix));
        analysis
      end
    else
      begin
        perform_full_closure @@ perform_closure_steps analysis
      end
  ;;

  let set_pdr_logger_level level =
    Ddpa_pds_reachability.set_logging_level level
  ;;

  let get_pdr_logger_level () =
    Ddpa_pds_reachability.get_logging_level ()
  ;;
end;;
